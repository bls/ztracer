// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ZTrace.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ztrace {

namespace {

const ::google::protobuf::Descriptor* MicroEventLog_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MicroEventLog_reflection_ = NULL;
const ::google::protobuf::Descriptor* InsDisassembly_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InsDisassembly_reflection_ = NULL;
const ::google::protobuf::Descriptor* BBLDisassembly_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BBLDisassembly_reflection_ = NULL;
const ::google::protobuf::Descriptor* TraceDisassembly_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TraceDisassembly_reflection_ = NULL;
const ::google::protobuf::Descriptor* Section_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Section_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Section_SectionType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ModuleLoad_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModuleLoad_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ModuleLoad_ImageType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ModuleUnload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModuleUnload_reflection_ = NULL;
const ::google::protobuf::Descriptor* SymbolEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SymbolEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModuleSymbols_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModuleSymbols_reflection_ = NULL;
const ::google::protobuf::Descriptor* Malloc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Malloc_reflection_ = NULL;
const ::google::protobuf::Descriptor* Calloc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Calloc_reflection_ = NULL;
const ::google::protobuf::Descriptor* Free_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Free_reflection_ = NULL;
const ::google::protobuf::Descriptor* Realloc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Realloc_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeapOperation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeapOperation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_reflection_ = NULL;
const ::google::protobuf::Descriptor* FunctionArgument_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FunctionArgument_reflection_ = NULL;
const ::google::protobuf::Descriptor* FunctionCall_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FunctionCall_reflection_ = NULL;
const ::google::protobuf::Descriptor* ThreadStart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ThreadStart_reflection_ = NULL;
const ::google::protobuf::Descriptor* ThreadEnd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ThreadEnd_reflection_ = NULL;
const ::google::protobuf::Descriptor* Timestamp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Timestamp_reflection_ = NULL;
const ::google::protobuf::Descriptor* TraceStart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TraceStart_reflection_ = NULL;
const ::google::protobuf::Descriptor* TraceEnd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TraceEnd_reflection_ = NULL;
const ::google::protobuf::Descriptor* MicroEventLogPtr_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MicroEventLogPtr_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Arch_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_ZTrace_2eproto() {
  protobuf_AddDesc_ZTrace_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ZTrace.proto");
  GOOGLE_CHECK(file != NULL);
  MicroEventLog_descriptor_ = file->message_type(0);
  static const int MicroEventLog_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLog, start_instruction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLog, data_),
  };
  MicroEventLog_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MicroEventLog_descriptor_,
      MicroEventLog::default_instance_,
      MicroEventLog_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLog, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLog, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MicroEventLog));
  InsDisassembly_descriptor_ = file->message_type(1);
  static const int InsDisassembly_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InsDisassembly, pc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InsDisassembly, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InsDisassembly, raw_bytes_),
  };
  InsDisassembly_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InsDisassembly_descriptor_,
      InsDisassembly::default_instance_,
      InsDisassembly_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InsDisassembly, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InsDisassembly, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InsDisassembly));
  BBLDisassembly_descriptor_ = file->message_type(2);
  static const int BBLDisassembly_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BBLDisassembly, ins_disasm_),
  };
  BBLDisassembly_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BBLDisassembly_descriptor_,
      BBLDisassembly::default_instance_,
      BBLDisassembly_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BBLDisassembly, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BBLDisassembly, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BBLDisassembly));
  TraceDisassembly_descriptor_ = file->message_type(3);
  static const int TraceDisassembly_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceDisassembly, bbl_disasm_),
  };
  TraceDisassembly_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TraceDisassembly_descriptor_,
      TraceDisassembly::default_instance_,
      TraceDisassembly_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceDisassembly, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceDisassembly, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TraceDisassembly));
  Section_descriptor_ = file->message_type(4);
  static const int Section_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, mapped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, is_readable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, is_writeable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, is_executable_),
  };
  Section_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Section_descriptor_,
      Section::default_instance_,
      Section_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Section, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Section));
  Section_SectionType_descriptor_ = Section_descriptor_->enum_type(0);
  ModuleLoad_descriptor_ = file->message_type(5);
  static const int ModuleLoad_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, low_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, high_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, load_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, image_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, is_main_executable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, is_static_executable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, section_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, contents_),
  };
  ModuleLoad_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModuleLoad_descriptor_,
      ModuleLoad::default_instance_,
      ModuleLoad_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleLoad, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModuleLoad));
  ModuleLoad_ImageType_descriptor_ = ModuleLoad_descriptor_->enum_type(0);
  ModuleUnload_descriptor_ = file->message_type(6);
  static const int ModuleUnload_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleUnload, id_),
  };
  ModuleUnload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModuleUnload_descriptor_,
      ModuleUnload::default_instance_,
      ModuleUnload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleUnload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleUnload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModuleUnload));
  SymbolEntry_descriptor_ = file->message_type(7);
  static const int SymbolEntry_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, undecorated_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, is_dynamic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, is_ifunc_),
  };
  SymbolEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SymbolEntry_descriptor_,
      SymbolEntry::default_instance_,
      SymbolEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymbolEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SymbolEntry));
  ModuleSymbols_descriptor_ = file->message_type(8);
  static const int ModuleSymbols_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleSymbols, module_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleSymbols, module_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleSymbols, sym_),
  };
  ModuleSymbols_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModuleSymbols_descriptor_,
      ModuleSymbols::default_instance_,
      ModuleSymbols_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleSymbols, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleSymbols, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModuleSymbols));
  Malloc_descriptor_ = file->message_type(9);
  static const int Malloc_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Malloc, n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Malloc, ret_),
  };
  Malloc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Malloc_descriptor_,
      Malloc::default_instance_,
      Malloc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Malloc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Malloc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Malloc));
  Calloc_descriptor_ = file->message_type(10);
  static const int Calloc_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Calloc, n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Calloc, ret_),
  };
  Calloc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Calloc_descriptor_,
      Calloc::default_instance_,
      Calloc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Calloc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Calloc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Calloc));
  Free_descriptor_ = file->message_type(11);
  static const int Free_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Free, p_),
  };
  Free_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Free_descriptor_,
      Free::default_instance_,
      Free_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Free, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Free, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Free));
  Realloc_descriptor_ = file->message_type(12);
  static const int Realloc_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Realloc, p_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Realloc, n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Realloc, ret_),
  };
  Realloc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Realloc_descriptor_,
      Realloc::default_instance_,
      Realloc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Realloc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Realloc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Realloc));
  HeapOperation_descriptor_ = file->message_type(13);
  static const int HeapOperation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeapOperation, malloc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeapOperation, free_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeapOperation, realloc_),
  };
  HeapOperation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeapOperation_descriptor_,
      HeapOperation::default_instance_,
      HeapOperation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeapOperation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeapOperation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeapOperation));
  Value_descriptor_ = file->message_type(14);
  static const int Value_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, v_uint64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, v_int64_),
  };
  Value_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_descriptor_,
      Value::default_instance_,
      Value_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value));
  FunctionArgument_descriptor_ = file->message_type(15);
  static const int FunctionArgument_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionArgument, value_),
  };
  FunctionArgument_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FunctionArgument_descriptor_,
      FunctionArgument::default_instance_,
      FunctionArgument_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionArgument, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionArgument, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FunctionArgument));
  FunctionCall_descriptor_ = file->message_type(16);
  static const int FunctionCall_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionCall, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionCall, module_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionCall, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionCall, arg_),
  };
  FunctionCall_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FunctionCall_descriptor_,
      FunctionCall::default_instance_,
      FunctionCall_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionCall, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionCall, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FunctionCall));
  ThreadStart_descriptor_ = file->message_type(17);
  static const int ThreadStart_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ThreadStart, flags_),
  };
  ThreadStart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ThreadStart_descriptor_,
      ThreadStart::default_instance_,
      ThreadStart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ThreadStart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ThreadStart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ThreadStart));
  ThreadEnd_descriptor_ = file->message_type(18);
  static const int ThreadEnd_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ThreadEnd, flags_),
  };
  ThreadEnd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ThreadEnd_descriptor_,
      ThreadEnd::default_instance_,
      ThreadEnd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ThreadEnd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ThreadEnd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ThreadEnd));
  Timestamp_descriptor_ = file->message_type(19);
  static const int Timestamp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, sec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, usec_),
  };
  Timestamp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Timestamp_descriptor_,
      Timestamp::default_instance_,
      Timestamp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Timestamp));
  TraceStart_descriptor_ = file->message_type(20);
  static const int TraceStart_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, arch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, software_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, cmdline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, os_uname_),
  };
  TraceStart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TraceStart_descriptor_,
      TraceStart::default_instance_,
      TraceStart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceStart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TraceStart));
  TraceEnd_descriptor_ = file->message_type(21);
  static const int TraceEnd_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceEnd, timestamp_),
  };
  TraceEnd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TraceEnd_descriptor_,
      TraceEnd::default_instance_,
      TraceEnd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceEnd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceEnd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TraceEnd));
  MicroEventLogPtr_descriptor_ = file->message_type(22);
  static const int MicroEventLogPtr_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLogPtr, tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLogPtr, next_instruction_),
  };
  MicroEventLogPtr_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MicroEventLogPtr_descriptor_,
      MicroEventLogPtr::default_instance_,
      MicroEventLogPtr_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLogPtr, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MicroEventLogPtr, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MicroEventLogPtr));
  Event_descriptor_ = file->message_type(23);
  static const int Event_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, cross_ref_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, trace_start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, trace_end_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, thread_start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, thread_end_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, trace_disasm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, mod_load_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, mod_unload_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, mod_symbols_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, micro_event_log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, malloc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, realloc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, free_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, calloc_),
  };
  Event_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_descriptor_,
      Event::default_instance_,
      Event_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event));
  Arch_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ZTrace_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MicroEventLog_descriptor_, &MicroEventLog::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InsDisassembly_descriptor_, &InsDisassembly::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BBLDisassembly_descriptor_, &BBLDisassembly::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TraceDisassembly_descriptor_, &TraceDisassembly::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Section_descriptor_, &Section::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModuleLoad_descriptor_, &ModuleLoad::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModuleUnload_descriptor_, &ModuleUnload::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SymbolEntry_descriptor_, &SymbolEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModuleSymbols_descriptor_, &ModuleSymbols::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Malloc_descriptor_, &Malloc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Calloc_descriptor_, &Calloc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Free_descriptor_, &Free::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Realloc_descriptor_, &Realloc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeapOperation_descriptor_, &HeapOperation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_descriptor_, &Value::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FunctionArgument_descriptor_, &FunctionArgument::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FunctionCall_descriptor_, &FunctionCall::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ThreadStart_descriptor_, &ThreadStart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ThreadEnd_descriptor_, &ThreadEnd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Timestamp_descriptor_, &Timestamp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TraceStart_descriptor_, &TraceStart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TraceEnd_descriptor_, &TraceEnd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MicroEventLogPtr_descriptor_, &MicroEventLogPtr::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_descriptor_, &Event::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ZTrace_2eproto() {
  delete MicroEventLog::default_instance_;
  delete MicroEventLog_reflection_;
  delete InsDisassembly::default_instance_;
  delete InsDisassembly_reflection_;
  delete BBLDisassembly::default_instance_;
  delete BBLDisassembly_reflection_;
  delete TraceDisassembly::default_instance_;
  delete TraceDisassembly_reflection_;
  delete Section::default_instance_;
  delete Section_reflection_;
  delete ModuleLoad::default_instance_;
  delete ModuleLoad_reflection_;
  delete ModuleUnload::default_instance_;
  delete ModuleUnload_reflection_;
  delete SymbolEntry::default_instance_;
  delete SymbolEntry_reflection_;
  delete ModuleSymbols::default_instance_;
  delete ModuleSymbols_reflection_;
  delete Malloc::default_instance_;
  delete Malloc_reflection_;
  delete Calloc::default_instance_;
  delete Calloc_reflection_;
  delete Free::default_instance_;
  delete Free_reflection_;
  delete Realloc::default_instance_;
  delete Realloc_reflection_;
  delete HeapOperation::default_instance_;
  delete HeapOperation_reflection_;
  delete Value::default_instance_;
  delete Value_reflection_;
  delete FunctionArgument::default_instance_;
  delete FunctionArgument_reflection_;
  delete FunctionCall::default_instance_;
  delete FunctionCall_reflection_;
  delete ThreadStart::default_instance_;
  delete ThreadStart_reflection_;
  delete ThreadEnd::default_instance_;
  delete ThreadEnd_reflection_;
  delete Timestamp::default_instance_;
  delete Timestamp_reflection_;
  delete TraceStart::default_instance_;
  delete TraceStart_reflection_;
  delete TraceEnd::default_instance_;
  delete TraceEnd_reflection_;
  delete MicroEventLogPtr::default_instance_;
  delete MicroEventLogPtr_reflection_;
  delete Event::default_instance_;
  delete Event_reflection_;
}

void protobuf_AddDesc_ZTrace_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::ztrace::protobuf_AddDesc_Registers_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014ZTrace.proto\022\006ztrace\032\017Registers.proto\""
    "8\n\rMicroEventLog\022\031\n\021start_instruction\030\001 "
    "\002(\004\022\014\n\004data\030\002 \002(\014\"=\n\016InsDisassembly\022\n\n\002p"
    "c\030\001 \002(\004\022\014\n\004text\030\002 \002(\t\022\021\n\traw_bytes\030\003 \001(\014"
    "\"<\n\016BBLDisassembly\022*\n\nins_disasm\030\001 \003(\0132\026"
    ".ztrace.InsDisassembly\">\n\020TraceDisassemb"
    "ly\022*\n\nbbl_disasm\030\001 \003(\0132\026.ztrace.BBLDisas"
    "sembly\"\327\005\n\007Section\022\014\n\004name\030\001 \002(\t\022\017\n\007addr"
    "ess\030\002 \002(\004\022\014\n\004size\030\003 \002(\004\022)\n\004type\030\004 \002(\0162\033."
    "ztrace.Section.SectionType\022\016\n\006mapped\030\005 \002"
    "(\010\022\023\n\013is_readable\030\006 \002(\010\022\024\n\014is_writeable\030"
    "\007 \002(\010\022\025\n\ris_executable\030\010 \002(\010\"\241\004\n\013Section"
    "Type\022\024\n\020SEC_TYPE_INVALID\020\000\022\023\n\017SEC_TYPE_U"
    "NUSED\020\001\022\023\n\017SEC_TYPE_REGREL\020\002\022\023\n\017SEC_TYPE"
    "_DYNREL\020\003\022\021\n\rSEC_TYPE_EXEC\020\004\022\021\n\rSEC_TYPE"
    "_DATA\020\005\022\024\n\020SEC_TYPE_DYNAMIC\020\006\022\020\n\014SEC_TYP"
    "E_OPD\020\007\022\020\n\014SEC_TYPE_GOT\020\010\022\022\n\016SEC_TYPE_ST"
    "ACK\020\t\022\023\n\017SEC_TYPE_PLTOFF\020\n\022\021\n\rSEC_TYPE_H"
    "ASH\020\013\022\021\n\rSEC_TYPE_LSDA\020\014\022\023\n\017SEC_TYPE_UNW"
    "IND\020\r\022\027\n\023SEC_TYPE_UNWINDINFO\020\016\022\023\n\017SEC_TY"
    "PE_REGSYM\020\017\022\023\n\017SEC_TYPE_DYNSYM\020\020\022\022\n\016SEC_"
    "TYPE_DEBUG\020\021\022\020\n\014SEC_TYPE_BSS\020\022\022\023\n\017SEC_TY"
    "PE_SYMSTR\020\023\022\023\n\017SEC_TYPE_DYNSTR\020\024\022\023\n\017SEC_"
    "TYPE_SECSTR\020\025\022\024\n\020SEC_TYPE_COMMENT\020\026\022\021\n\rS"
    "EC_TYPE_LOOS\020\027\022\021\n\rSEC_TYPE_USER\020\030\022\025\n\020SEC"
    "_TYPE_UNKNOWN\020\347\007\"\235\003\n\nModuleLoad\022\n\n\002id\030\001 "
    "\002(\r\022\014\n\004name\030\002 \002(\t\022\023\n\013low_address\030\003 \002(\004\022\024"
    "\n\014high_address\030\004 \002(\004\022\023\n\013load_offset\030\005 \002("
    "\004\0220\n\nimage_type\030\006 \002(\0162\034.ztrace.ModuleLoa"
    "d.ImageType\022\032\n\022is_main_executable\030\007 \002(\010\022"
    "\034\n\024is_static_executable\030\010 \002(\010\022 \n\007section"
    "\030\t \003(\0132\017.ztrace.Section\022\020\n\010contents\030\n \001("
    "\014\"\224\001\n\tImageType\022\024\n\020IMG_TYPE_INVALID\020\000\022\023\n"
    "\017IMG_TYPE_STATIC\020\001\022\023\n\017IMG_TYPE_SHARED\020\002\022"
    "\026\n\022IMG_TYPE_SHAREDLIB\020\003\022\030\n\024IMG_TYPE_RELO"
    "CATABLE\020\004\022\025\n\020IMG_TYPE_UNKNOWN\020\347\007\"\032\n\014Modu"
    "leUnload\022\n\n\002id\030\001 \002(\r\"l\n\013SymbolEntry\022\017\n\007a"
    "ddress\030\001 \002(\004\022\014\n\004name\030\002 \002(\t\022\030\n\020undecorate"
    "d_name\030\003 \002(\t\022\022\n\nis_dynamic\030\004 \002(\010\022\020\n\010is_i"
    "func\030\005 \002(\010\"Y\n\rModuleSymbols\022\021\n\tmodule_id"
    "\030\001 \002(\r\022\023\n\013module_name\030\002 \002(\t\022 \n\003sym\030\003 \003(\013"
    "2\023.ztrace.SymbolEntry\" \n\006Malloc\022\t\n\001n\030\001 \002"
    "(\004\022\013\n\003ret\030\002 \002(\004\" \n\006Calloc\022\t\n\001n\030\001 \002(\004\022\013\n\003"
    "ret\030\002 \002(\004\"\021\n\004Free\022\t\n\001p\030\001 \002(\004\",\n\007Realloc\022"
    "\t\n\001p\030\001 \002(\004\022\t\n\001n\030\002 \002(\004\022\013\n\003ret\030\003 \002(\004\"m\n\rHe"
    "apOperation\022\036\n\006malloc\030\001 \001(\0132\016.ztrace.Mal"
    "loc\022\032\n\004free\030\002 \001(\0132\014.ztrace.Free\022 \n\007reall"
    "oc\030\003 \001(\0132\017.ztrace.Realloc\"*\n\005Value\022\020\n\010v_"
    "uint64\030\001 \001(\004\022\017\n\007v_int64\030\002 \001(\003\"0\n\020Functio"
    "nArgument\022\034\n\005value\030\001 \002(\0132\r.ztrace.Value\""
    "g\n\014FunctionCall\022\014\n\004name\030\001 \002(\t\022\021\n\tmodule_"
    "id\030\002 \002(\r\022\032\n\003ret\030\003 \001(\0132\r.ztrace.Value\022\032\n\003"
    "arg\030\004 \003(\0132\r.ztrace.Value\"\034\n\013ThreadStart\022"
    "\r\n\005flags\030\001 \002(\r\"\032\n\tThreadEnd\022\r\n\005flags\030\002 \002"
    "(\r\"&\n\tTimestamp\022\013\n\003sec\030\001 \002(\r\022\014\n\004usec\030\002 \002"
    "(\r\"\223\001\n\nTraceStart\022$\n\ttimestamp\030\001 \002(\0132\021.z"
    "trace.Timestamp\022\032\n\004arch\030\002 \002(\0162\014.ztrace.A"
    "rch\022\020\n\010software\030\003 \001(\t\022\016\n\006target\030\004 \001(\t\022\017\n"
    "\007cmdline\030\005 \001(\t\022\020\n\010os_uname\030\006 \001(\t\"0\n\010Trac"
    "eEnd\022$\n\ttimestamp\030\002 \002(\0132\021.ztrace.Timesta"
    "mp\"9\n\020MicroEventLogPtr\022\013\n\003tid\030\001 \002(\r\022\030\n\020n"
    "ext_instruction\030\002 \002(\r\"\324\004\n\005Event\022\n\n\002id\030\001 "
    "\002(\r\022\013\n\003pid\030\002 \002(\r\022\013\n\003tid\030\003 \002(\r\022+\n\tcross_r"
    "ef\030d \003(\0132\030.ztrace.MicroEventLogPtr\022\'\n\013tr"
    "ace_start\030\n \001(\0132\022.ztrace.TraceStart\022#\n\tt"
    "race_end\030\013 \001(\0132\020.ztrace.TraceEnd\022)\n\014thre"
    "ad_start\030\024 \001(\0132\023.ztrace.ThreadStart\022%\n\nt"
    "hread_end\030\025 \001(\0132\021.ztrace.ThreadEnd\022.\n\014tr"
    "ace_disasm\030\036 \001(\0132\030.ztrace.TraceDisassemb"
    "ly\022$\n\010mod_load\030( \001(\0132\022.ztrace.ModuleLoad"
    "\022(\n\nmod_unload\030) \001(\0132\024.ztrace.ModuleUnlo"
    "ad\022*\n\013mod_symbols\030* \001(\0132\025.ztrace.ModuleS"
    "ymbols\022.\n\017micro_event_log\0302 \001(\0132\025.ztrace"
    ".MicroEventLog\022\036\n\006malloc\030< \001(\0132\016.ztrace."
    "Malloc\022 \n\007realloc\030= \001(\0132\017.ztrace.Realloc"
    "\022\032\n\004free\030> \001(\0132\014.ztrace.Free\022\036\n\006calloc\030\?"
    " \001(\0132\016.ztrace.Calloc*%\n\004Arch\022\014\n\010ARCH_X86"
    "\020\001\022\017\n\013ARCH_X86_64\020\002", 3099);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ZTrace.proto", &protobuf_RegisterTypes);
  MicroEventLog::default_instance_ = new MicroEventLog();
  InsDisassembly::default_instance_ = new InsDisassembly();
  BBLDisassembly::default_instance_ = new BBLDisassembly();
  TraceDisassembly::default_instance_ = new TraceDisassembly();
  Section::default_instance_ = new Section();
  ModuleLoad::default_instance_ = new ModuleLoad();
  ModuleUnload::default_instance_ = new ModuleUnload();
  SymbolEntry::default_instance_ = new SymbolEntry();
  ModuleSymbols::default_instance_ = new ModuleSymbols();
  Malloc::default_instance_ = new Malloc();
  Calloc::default_instance_ = new Calloc();
  Free::default_instance_ = new Free();
  Realloc::default_instance_ = new Realloc();
  HeapOperation::default_instance_ = new HeapOperation();
  Value::default_instance_ = new Value();
  FunctionArgument::default_instance_ = new FunctionArgument();
  FunctionCall::default_instance_ = new FunctionCall();
  ThreadStart::default_instance_ = new ThreadStart();
  ThreadEnd::default_instance_ = new ThreadEnd();
  Timestamp::default_instance_ = new Timestamp();
  TraceStart::default_instance_ = new TraceStart();
  TraceEnd::default_instance_ = new TraceEnd();
  MicroEventLogPtr::default_instance_ = new MicroEventLogPtr();
  Event::default_instance_ = new Event();
  MicroEventLog::default_instance_->InitAsDefaultInstance();
  InsDisassembly::default_instance_->InitAsDefaultInstance();
  BBLDisassembly::default_instance_->InitAsDefaultInstance();
  TraceDisassembly::default_instance_->InitAsDefaultInstance();
  Section::default_instance_->InitAsDefaultInstance();
  ModuleLoad::default_instance_->InitAsDefaultInstance();
  ModuleUnload::default_instance_->InitAsDefaultInstance();
  SymbolEntry::default_instance_->InitAsDefaultInstance();
  ModuleSymbols::default_instance_->InitAsDefaultInstance();
  Malloc::default_instance_->InitAsDefaultInstance();
  Calloc::default_instance_->InitAsDefaultInstance();
  Free::default_instance_->InitAsDefaultInstance();
  Realloc::default_instance_->InitAsDefaultInstance();
  HeapOperation::default_instance_->InitAsDefaultInstance();
  Value::default_instance_->InitAsDefaultInstance();
  FunctionArgument::default_instance_->InitAsDefaultInstance();
  FunctionCall::default_instance_->InitAsDefaultInstance();
  ThreadStart::default_instance_->InitAsDefaultInstance();
  ThreadEnd::default_instance_->InitAsDefaultInstance();
  Timestamp::default_instance_->InitAsDefaultInstance();
  TraceStart::default_instance_->InitAsDefaultInstance();
  TraceEnd::default_instance_->InitAsDefaultInstance();
  MicroEventLogPtr::default_instance_->InitAsDefaultInstance();
  Event::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ZTrace_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ZTrace_2eproto {
  StaticDescriptorInitializer_ZTrace_2eproto() {
    protobuf_AddDesc_ZTrace_2eproto();
  }
} static_descriptor_initializer_ZTrace_2eproto_;

const ::google::protobuf::EnumDescriptor* Arch_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Arch_descriptor_;
}
bool Arch_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MicroEventLog::kStartInstructionFieldNumber;
const int MicroEventLog::kDataFieldNumber;
#endif  // !_MSC_VER

MicroEventLog::MicroEventLog()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MicroEventLog::InitAsDefaultInstance() {
}

MicroEventLog::MicroEventLog(const MicroEventLog& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MicroEventLog::SharedCtor() {
  _cached_size_ = 0;
  start_instruction_ = GOOGLE_ULONGLONG(0);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MicroEventLog::~MicroEventLog() {
  SharedDtor();
}

void MicroEventLog::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void MicroEventLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MicroEventLog::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MicroEventLog_descriptor_;
}

const MicroEventLog& MicroEventLog::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

MicroEventLog* MicroEventLog::default_instance_ = NULL;

MicroEventLog* MicroEventLog::New() const {
  return new MicroEventLog;
}

void MicroEventLog::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_instruction_ = GOOGLE_ULONGLONG(0);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MicroEventLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 start_instruction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_instruction_)));
          set_has_start_instruction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }
      
      // required bytes data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MicroEventLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 start_instruction = 1;
  if (has_start_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->start_instruction(), output);
  }
  
  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->data(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MicroEventLog::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 start_instruction = 1;
  if (has_start_instruction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->start_instruction(), target);
  }
  
  // required bytes data = 2;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->data(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MicroEventLog::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 start_instruction = 1;
    if (has_start_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_instruction());
    }
    
    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MicroEventLog::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MicroEventLog* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MicroEventLog*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MicroEventLog::MergeFrom(const MicroEventLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_instruction()) {
      set_start_instruction(from.start_instruction());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MicroEventLog::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MicroEventLog::CopyFrom(const MicroEventLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MicroEventLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void MicroEventLog::Swap(MicroEventLog* other) {
  if (other != this) {
    std::swap(start_instruction_, other->start_instruction_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MicroEventLog::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MicroEventLog_descriptor_;
  metadata.reflection = MicroEventLog_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InsDisassembly::kPcFieldNumber;
const int InsDisassembly::kTextFieldNumber;
const int InsDisassembly::kRawBytesFieldNumber;
#endif  // !_MSC_VER

InsDisassembly::InsDisassembly()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InsDisassembly::InitAsDefaultInstance() {
}

InsDisassembly::InsDisassembly(const InsDisassembly& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InsDisassembly::SharedCtor() {
  _cached_size_ = 0;
  pc_ = GOOGLE_ULONGLONG(0);
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  raw_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InsDisassembly::~InsDisassembly() {
  SharedDtor();
}

void InsDisassembly::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (raw_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete raw_bytes_;
  }
  if (this != default_instance_) {
  }
}

void InsDisassembly::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InsDisassembly::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InsDisassembly_descriptor_;
}

const InsDisassembly& InsDisassembly::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

InsDisassembly* InsDisassembly::default_instance_ = NULL;

InsDisassembly* InsDisassembly::New() const {
  return new InsDisassembly;
}

void InsDisassembly::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pc_ = GOOGLE_ULONGLONG(0);
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    if (has_raw_bytes()) {
      if (raw_bytes_ != &::google::protobuf::internal::kEmptyString) {
        raw_bytes_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InsDisassembly::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 pc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pc_)));
          set_has_pc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_text;
        break;
      }
      
      // required string text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_raw_bytes;
        break;
      }
      
      // optional bytes raw_bytes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_raw_bytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_raw_bytes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InsDisassembly::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 pc = 1;
  if (has_pc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->pc(), output);
  }
  
  // required string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->text(), output);
  }
  
  // optional bytes raw_bytes = 3;
  if (has_raw_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->raw_bytes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InsDisassembly::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 pc = 1;
  if (has_pc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->pc(), target);
  }
  
  // required string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }
  
  // optional bytes raw_bytes = 3;
  if (has_raw_bytes()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->raw_bytes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InsDisassembly::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 pc = 1;
    if (has_pc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pc());
    }
    
    // required string text = 2;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
    // optional bytes raw_bytes = 3;
    if (has_raw_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->raw_bytes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InsDisassembly::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InsDisassembly* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InsDisassembly*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InsDisassembly::MergeFrom(const InsDisassembly& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pc()) {
      set_pc(from.pc());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_raw_bytes()) {
      set_raw_bytes(from.raw_bytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InsDisassembly::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InsDisassembly::CopyFrom(const InsDisassembly& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsDisassembly::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void InsDisassembly::Swap(InsDisassembly* other) {
  if (other != this) {
    std::swap(pc_, other->pc_);
    std::swap(text_, other->text_);
    std::swap(raw_bytes_, other->raw_bytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InsDisassembly::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InsDisassembly_descriptor_;
  metadata.reflection = InsDisassembly_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BBLDisassembly::kInsDisasmFieldNumber;
#endif  // !_MSC_VER

BBLDisassembly::BBLDisassembly()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BBLDisassembly::InitAsDefaultInstance() {
}

BBLDisassembly::BBLDisassembly(const BBLDisassembly& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BBLDisassembly::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BBLDisassembly::~BBLDisassembly() {
  SharedDtor();
}

void BBLDisassembly::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BBLDisassembly::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BBLDisassembly::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BBLDisassembly_descriptor_;
}

const BBLDisassembly& BBLDisassembly::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

BBLDisassembly* BBLDisassembly::default_instance_ = NULL;

BBLDisassembly* BBLDisassembly::New() const {
  return new BBLDisassembly;
}

void BBLDisassembly::Clear() {
  ins_disasm_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BBLDisassembly::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ztrace.InsDisassembly ins_disasm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ins_disasm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ins_disasm()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_ins_disasm;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BBLDisassembly::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ztrace.InsDisassembly ins_disasm = 1;
  for (int i = 0; i < this->ins_disasm_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ins_disasm(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BBLDisassembly::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ztrace.InsDisassembly ins_disasm = 1;
  for (int i = 0; i < this->ins_disasm_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ins_disasm(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BBLDisassembly::ByteSize() const {
  int total_size = 0;
  
  // repeated .ztrace.InsDisassembly ins_disasm = 1;
  total_size += 1 * this->ins_disasm_size();
  for (int i = 0; i < this->ins_disasm_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ins_disasm(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BBLDisassembly::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BBLDisassembly* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BBLDisassembly*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BBLDisassembly::MergeFrom(const BBLDisassembly& from) {
  GOOGLE_CHECK_NE(&from, this);
  ins_disasm_.MergeFrom(from.ins_disasm_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BBLDisassembly::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BBLDisassembly::CopyFrom(const BBLDisassembly& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BBLDisassembly::IsInitialized() const {
  
  for (int i = 0; i < ins_disasm_size(); i++) {
    if (!this->ins_disasm(i).IsInitialized()) return false;
  }
  return true;
}

void BBLDisassembly::Swap(BBLDisassembly* other) {
  if (other != this) {
    ins_disasm_.Swap(&other->ins_disasm_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BBLDisassembly::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BBLDisassembly_descriptor_;
  metadata.reflection = BBLDisassembly_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TraceDisassembly::kBblDisasmFieldNumber;
#endif  // !_MSC_VER

TraceDisassembly::TraceDisassembly()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TraceDisassembly::InitAsDefaultInstance() {
}

TraceDisassembly::TraceDisassembly(const TraceDisassembly& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TraceDisassembly::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceDisassembly::~TraceDisassembly() {
  SharedDtor();
}

void TraceDisassembly::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TraceDisassembly::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TraceDisassembly::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TraceDisassembly_descriptor_;
}

const TraceDisassembly& TraceDisassembly::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

TraceDisassembly* TraceDisassembly::default_instance_ = NULL;

TraceDisassembly* TraceDisassembly::New() const {
  return new TraceDisassembly;
}

void TraceDisassembly::Clear() {
  bbl_disasm_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TraceDisassembly::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ztrace.BBLDisassembly bbl_disasm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bbl_disasm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bbl_disasm()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_bbl_disasm;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TraceDisassembly::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ztrace.BBLDisassembly bbl_disasm = 1;
  for (int i = 0; i < this->bbl_disasm_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->bbl_disasm(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TraceDisassembly::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ztrace.BBLDisassembly bbl_disasm = 1;
  for (int i = 0; i < this->bbl_disasm_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->bbl_disasm(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TraceDisassembly::ByteSize() const {
  int total_size = 0;
  
  // repeated .ztrace.BBLDisassembly bbl_disasm = 1;
  total_size += 1 * this->bbl_disasm_size();
  for (int i = 0; i < this->bbl_disasm_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bbl_disasm(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceDisassembly::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TraceDisassembly* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TraceDisassembly*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TraceDisassembly::MergeFrom(const TraceDisassembly& from) {
  GOOGLE_CHECK_NE(&from, this);
  bbl_disasm_.MergeFrom(from.bbl_disasm_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TraceDisassembly::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TraceDisassembly::CopyFrom(const TraceDisassembly& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceDisassembly::IsInitialized() const {
  
  for (int i = 0; i < bbl_disasm_size(); i++) {
    if (!this->bbl_disasm(i).IsInitialized()) return false;
  }
  return true;
}

void TraceDisassembly::Swap(TraceDisassembly* other) {
  if (other != this) {
    bbl_disasm_.Swap(&other->bbl_disasm_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TraceDisassembly::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TraceDisassembly_descriptor_;
  metadata.reflection = TraceDisassembly_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Section_SectionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Section_SectionType_descriptor_;
}
bool Section_SectionType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 999:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Section_SectionType Section::SEC_TYPE_INVALID;
const Section_SectionType Section::SEC_TYPE_UNUSED;
const Section_SectionType Section::SEC_TYPE_REGREL;
const Section_SectionType Section::SEC_TYPE_DYNREL;
const Section_SectionType Section::SEC_TYPE_EXEC;
const Section_SectionType Section::SEC_TYPE_DATA;
const Section_SectionType Section::SEC_TYPE_DYNAMIC;
const Section_SectionType Section::SEC_TYPE_OPD;
const Section_SectionType Section::SEC_TYPE_GOT;
const Section_SectionType Section::SEC_TYPE_STACK;
const Section_SectionType Section::SEC_TYPE_PLTOFF;
const Section_SectionType Section::SEC_TYPE_HASH;
const Section_SectionType Section::SEC_TYPE_LSDA;
const Section_SectionType Section::SEC_TYPE_UNWIND;
const Section_SectionType Section::SEC_TYPE_UNWINDINFO;
const Section_SectionType Section::SEC_TYPE_REGSYM;
const Section_SectionType Section::SEC_TYPE_DYNSYM;
const Section_SectionType Section::SEC_TYPE_DEBUG;
const Section_SectionType Section::SEC_TYPE_BSS;
const Section_SectionType Section::SEC_TYPE_SYMSTR;
const Section_SectionType Section::SEC_TYPE_DYNSTR;
const Section_SectionType Section::SEC_TYPE_SECSTR;
const Section_SectionType Section::SEC_TYPE_COMMENT;
const Section_SectionType Section::SEC_TYPE_LOOS;
const Section_SectionType Section::SEC_TYPE_USER;
const Section_SectionType Section::SEC_TYPE_UNKNOWN;
const Section_SectionType Section::SectionType_MIN;
const Section_SectionType Section::SectionType_MAX;
const int Section::SectionType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Section::kNameFieldNumber;
const int Section::kAddressFieldNumber;
const int Section::kSizeFieldNumber;
const int Section::kTypeFieldNumber;
const int Section::kMappedFieldNumber;
const int Section::kIsReadableFieldNumber;
const int Section::kIsWriteableFieldNumber;
const int Section::kIsExecutableFieldNumber;
#endif  // !_MSC_VER

Section::Section()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Section::InitAsDefaultInstance() {
}

Section::Section(const Section& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Section::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_ = GOOGLE_ULONGLONG(0);
  size_ = GOOGLE_ULONGLONG(0);
  type_ = 0;
  mapped_ = false;
  is_readable_ = false;
  is_writeable_ = false;
  is_executable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Section::~Section() {
  SharedDtor();
}

void Section::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Section::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Section::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Section_descriptor_;
}

const Section& Section::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Section* Section::default_instance_ = NULL;

Section* Section::New() const {
  return new Section;
}

void Section::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    address_ = GOOGLE_ULONGLONG(0);
    size_ = GOOGLE_ULONGLONG(0);
    type_ = 0;
    mapped_ = false;
    is_readable_ = false;
    is_writeable_ = false;
    is_executable_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Section::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address;
        break;
      }
      
      // required uint64 address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &address_)));
          set_has_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }
      
      // required uint64 size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }
      
      // required .ztrace.Section.SectionType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ztrace::Section_SectionType_IsValid(value)) {
            set_type(static_cast< ::ztrace::Section_SectionType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_mapped;
        break;
      }
      
      // required bool mapped = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mapped_)));
          set_has_mapped();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_is_readable;
        break;
      }
      
      // required bool is_readable = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_readable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_readable_)));
          set_has_is_readable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_is_writeable;
        break;
      }
      
      // required bool is_writeable = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_writeable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_writeable_)));
          set_has_is_writeable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_is_executable;
        break;
      }
      
      // required bool is_executable = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_executable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_executable_)));
          set_has_is_executable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Section::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required uint64 address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->address(), output);
  }
  
  // required uint64 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->size(), output);
  }
  
  // required .ztrace.Section.SectionType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }
  
  // required bool mapped = 5;
  if (has_mapped()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->mapped(), output);
  }
  
  // required bool is_readable = 6;
  if (has_is_readable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_readable(), output);
  }
  
  // required bool is_writeable = 7;
  if (has_is_writeable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_writeable(), output);
  }
  
  // required bool is_executable = 8;
  if (has_is_executable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_executable(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Section::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required uint64 address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->address(), target);
  }
  
  // required uint64 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->size(), target);
  }
  
  // required .ztrace.Section.SectionType type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }
  
  // required bool mapped = 5;
  if (has_mapped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->mapped(), target);
  }
  
  // required bool is_readable = 6;
  if (has_is_readable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->is_readable(), target);
  }
  
  // required bool is_writeable = 7;
  if (has_is_writeable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->is_writeable(), target);
  }
  
  // required bool is_executable = 8;
  if (has_is_executable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->is_executable(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Section::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required uint64 address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->address());
    }
    
    // required uint64 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }
    
    // required .ztrace.Section.SectionType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // required bool mapped = 5;
    if (has_mapped()) {
      total_size += 1 + 1;
    }
    
    // required bool is_readable = 6;
    if (has_is_readable()) {
      total_size += 1 + 1;
    }
    
    // required bool is_writeable = 7;
    if (has_is_writeable()) {
      total_size += 1 + 1;
    }
    
    // required bool is_executable = 8;
    if (has_is_executable()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Section::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Section* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Section*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Section::MergeFrom(const Section& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_mapped()) {
      set_mapped(from.mapped());
    }
    if (from.has_is_readable()) {
      set_is_readable(from.is_readable());
    }
    if (from.has_is_writeable()) {
      set_is_writeable(from.is_writeable());
    }
    if (from.has_is_executable()) {
      set_is_executable(from.is_executable());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Section::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Section::CopyFrom(const Section& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Section::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;
  
  return true;
}

void Section::Swap(Section* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(address_, other->address_);
    std::swap(size_, other->size_);
    std::swap(type_, other->type_);
    std::swap(mapped_, other->mapped_);
    std::swap(is_readable_, other->is_readable_);
    std::swap(is_writeable_, other->is_writeable_);
    std::swap(is_executable_, other->is_executable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Section::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Section_descriptor_;
  metadata.reflection = Section_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ModuleLoad_ImageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModuleLoad_ImageType_descriptor_;
}
bool ModuleLoad_ImageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 999:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModuleLoad_ImageType ModuleLoad::IMG_TYPE_INVALID;
const ModuleLoad_ImageType ModuleLoad::IMG_TYPE_STATIC;
const ModuleLoad_ImageType ModuleLoad::IMG_TYPE_SHARED;
const ModuleLoad_ImageType ModuleLoad::IMG_TYPE_SHAREDLIB;
const ModuleLoad_ImageType ModuleLoad::IMG_TYPE_RELOCATABLE;
const ModuleLoad_ImageType ModuleLoad::IMG_TYPE_UNKNOWN;
const ModuleLoad_ImageType ModuleLoad::ImageType_MIN;
const ModuleLoad_ImageType ModuleLoad::ImageType_MAX;
const int ModuleLoad::ImageType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ModuleLoad::kIdFieldNumber;
const int ModuleLoad::kNameFieldNumber;
const int ModuleLoad::kLowAddressFieldNumber;
const int ModuleLoad::kHighAddressFieldNumber;
const int ModuleLoad::kLoadOffsetFieldNumber;
const int ModuleLoad::kImageTypeFieldNumber;
const int ModuleLoad::kIsMainExecutableFieldNumber;
const int ModuleLoad::kIsStaticExecutableFieldNumber;
const int ModuleLoad::kSectionFieldNumber;
const int ModuleLoad::kContentsFieldNumber;
#endif  // !_MSC_VER

ModuleLoad::ModuleLoad()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ModuleLoad::InitAsDefaultInstance() {
}

ModuleLoad::ModuleLoad(const ModuleLoad& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ModuleLoad::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  low_address_ = GOOGLE_ULONGLONG(0);
  high_address_ = GOOGLE_ULONGLONG(0);
  load_offset_ = GOOGLE_ULONGLONG(0);
  image_type_ = 0;
  is_main_executable_ = false;
  is_static_executable_ = false;
  contents_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModuleLoad::~ModuleLoad() {
  SharedDtor();
}

void ModuleLoad::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (contents_ != &::google::protobuf::internal::kEmptyString) {
    delete contents_;
  }
  if (this != default_instance_) {
  }
}

void ModuleLoad::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModuleLoad::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModuleLoad_descriptor_;
}

const ModuleLoad& ModuleLoad::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

ModuleLoad* ModuleLoad::default_instance_ = NULL;

ModuleLoad* ModuleLoad::New() const {
  return new ModuleLoad;
}

void ModuleLoad::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    low_address_ = GOOGLE_ULONGLONG(0);
    high_address_ = GOOGLE_ULONGLONG(0);
    load_offset_ = GOOGLE_ULONGLONG(0);
    image_type_ = 0;
    is_main_executable_ = false;
    is_static_executable_ = false;
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (has_contents()) {
      if (contents_ != &::google::protobuf::internal::kEmptyString) {
        contents_->clear();
      }
    }
  }
  section_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModuleLoad::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_low_address;
        break;
      }
      
      // required uint64 low_address = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_low_address:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &low_address_)));
          set_has_low_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_high_address;
        break;
      }
      
      // required uint64 high_address = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_high_address:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &high_address_)));
          set_has_high_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_load_offset;
        break;
      }
      
      // required uint64 load_offset = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_load_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &load_offset_)));
          set_has_load_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_image_type;
        break;
      }
      
      // required .ztrace.ModuleLoad.ImageType image_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_image_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ztrace::ModuleLoad_ImageType_IsValid(value)) {
            set_image_type(static_cast< ::ztrace::ModuleLoad_ImageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_is_main_executable;
        break;
      }
      
      // required bool is_main_executable = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_main_executable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_main_executable_)));
          set_has_is_main_executable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_is_static_executable;
        break;
      }
      
      // required bool is_static_executable = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_static_executable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_static_executable_)));
          set_has_is_static_executable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_section;
        break;
      }
      
      // repeated .ztrace.Section section = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_section:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_section()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_section;
        if (input->ExpectTag(82)) goto parse_contents;
        break;
      }
      
      // optional bytes contents = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_contents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_contents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ModuleLoad::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // required uint64 low_address = 3;
  if (has_low_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->low_address(), output);
  }
  
  // required uint64 high_address = 4;
  if (has_high_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->high_address(), output);
  }
  
  // required uint64 load_offset = 5;
  if (has_load_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->load_offset(), output);
  }
  
  // required .ztrace.ModuleLoad.ImageType image_type = 6;
  if (has_image_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->image_type(), output);
  }
  
  // required bool is_main_executable = 7;
  if (has_is_main_executable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_main_executable(), output);
  }
  
  // required bool is_static_executable = 8;
  if (has_is_static_executable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_static_executable(), output);
  }
  
  // repeated .ztrace.Section section = 9;
  for (int i = 0; i < this->section_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->section(i), output);
  }
  
  // optional bytes contents = 10;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->contents(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ModuleLoad::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // required uint64 low_address = 3;
  if (has_low_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->low_address(), target);
  }
  
  // required uint64 high_address = 4;
  if (has_high_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->high_address(), target);
  }
  
  // required uint64 load_offset = 5;
  if (has_load_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->load_offset(), target);
  }
  
  // required .ztrace.ModuleLoad.ImageType image_type = 6;
  if (has_image_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->image_type(), target);
  }
  
  // required bool is_main_executable = 7;
  if (has_is_main_executable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->is_main_executable(), target);
  }
  
  // required bool is_static_executable = 8;
  if (has_is_static_executable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->is_static_executable(), target);
  }
  
  // repeated .ztrace.Section section = 9;
  for (int i = 0; i < this->section_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->section(i), target);
  }
  
  // optional bytes contents = 10;
  if (has_contents()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->contents(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ModuleLoad::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required uint64 low_address = 3;
    if (has_low_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->low_address());
    }
    
    // required uint64 high_address = 4;
    if (has_high_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->high_address());
    }
    
    // required uint64 load_offset = 5;
    if (has_load_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->load_offset());
    }
    
    // required .ztrace.ModuleLoad.ImageType image_type = 6;
    if (has_image_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->image_type());
    }
    
    // required bool is_main_executable = 7;
    if (has_is_main_executable()) {
      total_size += 1 + 1;
    }
    
    // required bool is_static_executable = 8;
    if (has_is_static_executable()) {
      total_size += 1 + 1;
    }
    
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional bytes contents = 10;
    if (has_contents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->contents());
    }
    
  }
  // repeated .ztrace.Section section = 9;
  total_size += 1 * this->section_size();
  for (int i = 0; i < this->section_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->section(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModuleLoad::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModuleLoad* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModuleLoad*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModuleLoad::MergeFrom(const ModuleLoad& from) {
  GOOGLE_CHECK_NE(&from, this);
  section_.MergeFrom(from.section_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_low_address()) {
      set_low_address(from.low_address());
    }
    if (from.has_high_address()) {
      set_high_address(from.high_address());
    }
    if (from.has_load_offset()) {
      set_load_offset(from.load_offset());
    }
    if (from.has_image_type()) {
      set_image_type(from.image_type());
    }
    if (from.has_is_main_executable()) {
      set_is_main_executable(from.is_main_executable());
    }
    if (from.has_is_static_executable()) {
      set_is_static_executable(from.is_static_executable());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_contents()) {
      set_contents(from.contents());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModuleLoad::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModuleLoad::CopyFrom(const ModuleLoad& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleLoad::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;
  
  for (int i = 0; i < section_size(); i++) {
    if (!this->section(i).IsInitialized()) return false;
  }
  return true;
}

void ModuleLoad::Swap(ModuleLoad* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(low_address_, other->low_address_);
    std::swap(high_address_, other->high_address_);
    std::swap(load_offset_, other->load_offset_);
    std::swap(image_type_, other->image_type_);
    std::swap(is_main_executable_, other->is_main_executable_);
    std::swap(is_static_executable_, other->is_static_executable_);
    section_.Swap(&other->section_);
    std::swap(contents_, other->contents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModuleLoad::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModuleLoad_descriptor_;
  metadata.reflection = ModuleLoad_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModuleUnload::kIdFieldNumber;
#endif  // !_MSC_VER

ModuleUnload::ModuleUnload()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ModuleUnload::InitAsDefaultInstance() {
}

ModuleUnload::ModuleUnload(const ModuleUnload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ModuleUnload::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModuleUnload::~ModuleUnload() {
  SharedDtor();
}

void ModuleUnload::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModuleUnload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModuleUnload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModuleUnload_descriptor_;
}

const ModuleUnload& ModuleUnload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

ModuleUnload* ModuleUnload::default_instance_ = NULL;

ModuleUnload* ModuleUnload::New() const {
  return new ModuleUnload;
}

void ModuleUnload::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModuleUnload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ModuleUnload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ModuleUnload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ModuleUnload::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModuleUnload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModuleUnload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModuleUnload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModuleUnload::MergeFrom(const ModuleUnload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModuleUnload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModuleUnload::CopyFrom(const ModuleUnload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleUnload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ModuleUnload::Swap(ModuleUnload* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModuleUnload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModuleUnload_descriptor_;
  metadata.reflection = ModuleUnload_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SymbolEntry::kAddressFieldNumber;
const int SymbolEntry::kNameFieldNumber;
const int SymbolEntry::kUndecoratedNameFieldNumber;
const int SymbolEntry::kIsDynamicFieldNumber;
const int SymbolEntry::kIsIfuncFieldNumber;
#endif  // !_MSC_VER

SymbolEntry::SymbolEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SymbolEntry::InitAsDefaultInstance() {
}

SymbolEntry::SymbolEntry(const SymbolEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SymbolEntry::SharedCtor() {
  _cached_size_ = 0;
  address_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  undecorated_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_dynamic_ = false;
  is_ifunc_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SymbolEntry::~SymbolEntry() {
  SharedDtor();
}

void SymbolEntry::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (undecorated_name_ != &::google::protobuf::internal::kEmptyString) {
    delete undecorated_name_;
  }
  if (this != default_instance_) {
  }
}

void SymbolEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SymbolEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SymbolEntry_descriptor_;
}

const SymbolEntry& SymbolEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

SymbolEntry* SymbolEntry::default_instance_ = NULL;

SymbolEntry* SymbolEntry::New() const {
  return new SymbolEntry;
}

void SymbolEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    address_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_undecorated_name()) {
      if (undecorated_name_ != &::google::protobuf::internal::kEmptyString) {
        undecorated_name_->clear();
      }
    }
    is_dynamic_ = false;
    is_ifunc_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SymbolEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &address_)));
          set_has_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_undecorated_name;
        break;
      }
      
      // required string undecorated_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_undecorated_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_undecorated_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->undecorated_name().data(), this->undecorated_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_dynamic;
        break;
      }
      
      // required bool is_dynamic = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_dynamic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_dynamic_)));
          set_has_is_dynamic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_ifunc;
        break;
      }
      
      // required bool is_ifunc = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_ifunc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_ifunc_)));
          set_has_is_ifunc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SymbolEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->address(), output);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // required string undecorated_name = 3;
  if (has_undecorated_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->undecorated_name().data(), this->undecorated_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->undecorated_name(), output);
  }
  
  // required bool is_dynamic = 4;
  if (has_is_dynamic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_dynamic(), output);
  }
  
  // required bool is_ifunc = 5;
  if (has_is_ifunc()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->is_ifunc(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SymbolEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 address = 1;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->address(), target);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // required string undecorated_name = 3;
  if (has_undecorated_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->undecorated_name().data(), this->undecorated_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->undecorated_name(), target);
  }
  
  // required bool is_dynamic = 4;
  if (has_is_dynamic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->is_dynamic(), target);
  }
  
  // required bool is_ifunc = 5;
  if (has_is_ifunc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->is_ifunc(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SymbolEntry::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->address());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required string undecorated_name = 3;
    if (has_undecorated_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->undecorated_name());
    }
    
    // required bool is_dynamic = 4;
    if (has_is_dynamic()) {
      total_size += 1 + 1;
    }
    
    // required bool is_ifunc = 5;
    if (has_is_ifunc()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SymbolEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SymbolEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SymbolEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SymbolEntry::MergeFrom(const SymbolEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_undecorated_name()) {
      set_undecorated_name(from.undecorated_name());
    }
    if (from.has_is_dynamic()) {
      set_is_dynamic(from.is_dynamic());
    }
    if (from.has_is_ifunc()) {
      set_is_ifunc(from.is_ifunc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SymbolEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SymbolEntry::CopyFrom(const SymbolEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymbolEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void SymbolEntry::Swap(SymbolEntry* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(name_, other->name_);
    std::swap(undecorated_name_, other->undecorated_name_);
    std::swap(is_dynamic_, other->is_dynamic_);
    std::swap(is_ifunc_, other->is_ifunc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SymbolEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SymbolEntry_descriptor_;
  metadata.reflection = SymbolEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModuleSymbols::kModuleIdFieldNumber;
const int ModuleSymbols::kModuleNameFieldNumber;
const int ModuleSymbols::kSymFieldNumber;
#endif  // !_MSC_VER

ModuleSymbols::ModuleSymbols()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ModuleSymbols::InitAsDefaultInstance() {
}

ModuleSymbols::ModuleSymbols(const ModuleSymbols& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ModuleSymbols::SharedCtor() {
  _cached_size_ = 0;
  module_id_ = 0u;
  module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModuleSymbols::~ModuleSymbols() {
  SharedDtor();
}

void ModuleSymbols::SharedDtor() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    delete module_name_;
  }
  if (this != default_instance_) {
  }
}

void ModuleSymbols::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModuleSymbols::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModuleSymbols_descriptor_;
}

const ModuleSymbols& ModuleSymbols::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

ModuleSymbols* ModuleSymbols::default_instance_ = NULL;

ModuleSymbols* ModuleSymbols::New() const {
  return new ModuleSymbols;
}

void ModuleSymbols::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    module_id_ = 0u;
    if (has_module_name()) {
      if (module_name_ != &::google::protobuf::internal::kEmptyString) {
        module_name_->clear();
      }
    }
  }
  sym_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModuleSymbols::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 module_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &module_id_)));
          set_has_module_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_module_name;
        break;
      }
      
      // required string module_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_module_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_module_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->module_name().data(), this->module_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sym;
        break;
      }
      
      // repeated .ztrace.SymbolEntry sym = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sym:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sym()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sym;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ModuleSymbols::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 module_id = 1;
  if (has_module_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->module_id(), output);
  }
  
  // required string module_name = 2;
  if (has_module_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->module_name().data(), this->module_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->module_name(), output);
  }
  
  // repeated .ztrace.SymbolEntry sym = 3;
  for (int i = 0; i < this->sym_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sym(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ModuleSymbols::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 module_id = 1;
  if (has_module_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->module_id(), target);
  }
  
  // required string module_name = 2;
  if (has_module_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->module_name().data(), this->module_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->module_name(), target);
  }
  
  // repeated .ztrace.SymbolEntry sym = 3;
  for (int i = 0; i < this->sym_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sym(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ModuleSymbols::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 module_id = 1;
    if (has_module_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->module_id());
    }
    
    // required string module_name = 2;
    if (has_module_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->module_name());
    }
    
  }
  // repeated .ztrace.SymbolEntry sym = 3;
  total_size += 1 * this->sym_size();
  for (int i = 0; i < this->sym_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sym(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModuleSymbols::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModuleSymbols* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModuleSymbols*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModuleSymbols::MergeFrom(const ModuleSymbols& from) {
  GOOGLE_CHECK_NE(&from, this);
  sym_.MergeFrom(from.sym_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_module_id()) {
      set_module_id(from.module_id());
    }
    if (from.has_module_name()) {
      set_module_name(from.module_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModuleSymbols::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModuleSymbols::CopyFrom(const ModuleSymbols& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleSymbols::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < sym_size(); i++) {
    if (!this->sym(i).IsInitialized()) return false;
  }
  return true;
}

void ModuleSymbols::Swap(ModuleSymbols* other) {
  if (other != this) {
    std::swap(module_id_, other->module_id_);
    std::swap(module_name_, other->module_name_);
    sym_.Swap(&other->sym_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModuleSymbols::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModuleSymbols_descriptor_;
  metadata.reflection = ModuleSymbols_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Malloc::kNFieldNumber;
const int Malloc::kRetFieldNumber;
#endif  // !_MSC_VER

Malloc::Malloc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Malloc::InitAsDefaultInstance() {
}

Malloc::Malloc(const Malloc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Malloc::SharedCtor() {
  _cached_size_ = 0;
  n_ = GOOGLE_ULONGLONG(0);
  ret_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Malloc::~Malloc() {
  SharedDtor();
}

void Malloc::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Malloc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Malloc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Malloc_descriptor_;
}

const Malloc& Malloc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Malloc* Malloc::default_instance_ = NULL;

Malloc* Malloc::New() const {
  return new Malloc;
}

void Malloc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    n_ = GOOGLE_ULONGLONG(0);
    ret_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Malloc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &n_)));
          set_has_n();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ret;
        break;
      }
      
      // required uint64 ret = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Malloc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 n = 1;
  if (has_n()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->n(), output);
  }
  
  // required uint64 ret = 2;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->ret(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Malloc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 n = 1;
  if (has_n()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->n(), target);
  }
  
  // required uint64 ret = 2;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->ret(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Malloc::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 n = 1;
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->n());
    }
    
    // required uint64 ret = 2;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ret());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Malloc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Malloc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Malloc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Malloc::MergeFrom(const Malloc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_n()) {
      set_n(from.n());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Malloc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Malloc::CopyFrom(const Malloc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Malloc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Malloc::Swap(Malloc* other) {
  if (other != this) {
    std::swap(n_, other->n_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Malloc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Malloc_descriptor_;
  metadata.reflection = Malloc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Calloc::kNFieldNumber;
const int Calloc::kRetFieldNumber;
#endif  // !_MSC_VER

Calloc::Calloc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Calloc::InitAsDefaultInstance() {
}

Calloc::Calloc(const Calloc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Calloc::SharedCtor() {
  _cached_size_ = 0;
  n_ = GOOGLE_ULONGLONG(0);
  ret_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Calloc::~Calloc() {
  SharedDtor();
}

void Calloc::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Calloc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Calloc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Calloc_descriptor_;
}

const Calloc& Calloc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Calloc* Calloc::default_instance_ = NULL;

Calloc* Calloc::New() const {
  return new Calloc;
}

void Calloc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    n_ = GOOGLE_ULONGLONG(0);
    ret_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Calloc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &n_)));
          set_has_n();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ret;
        break;
      }
      
      // required uint64 ret = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Calloc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 n = 1;
  if (has_n()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->n(), output);
  }
  
  // required uint64 ret = 2;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->ret(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Calloc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 n = 1;
  if (has_n()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->n(), target);
  }
  
  // required uint64 ret = 2;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->ret(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Calloc::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 n = 1;
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->n());
    }
    
    // required uint64 ret = 2;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ret());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Calloc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Calloc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Calloc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Calloc::MergeFrom(const Calloc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_n()) {
      set_n(from.n());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Calloc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Calloc::CopyFrom(const Calloc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Calloc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Calloc::Swap(Calloc* other) {
  if (other != this) {
    std::swap(n_, other->n_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Calloc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Calloc_descriptor_;
  metadata.reflection = Calloc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Free::kPFieldNumber;
#endif  // !_MSC_VER

Free::Free()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Free::InitAsDefaultInstance() {
}

Free::Free(const Free& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Free::SharedCtor() {
  _cached_size_ = 0;
  p_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Free::~Free() {
  SharedDtor();
}

void Free::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Free::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Free::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Free_descriptor_;
}

const Free& Free::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Free* Free::default_instance_ = NULL;

Free* Free::New() const {
  return new Free;
}

void Free::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    p_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Free::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 p = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &p_)));
          set_has_p();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Free::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 p = 1;
  if (has_p()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->p(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Free::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 p = 1;
  if (has_p()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->p(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Free::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 p = 1;
    if (has_p()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->p());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Free::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Free* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Free*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Free::MergeFrom(const Free& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_p()) {
      set_p(from.p());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Free::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Free::CopyFrom(const Free& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Free::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Free::Swap(Free* other) {
  if (other != this) {
    std::swap(p_, other->p_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Free::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Free_descriptor_;
  metadata.reflection = Free_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Realloc::kPFieldNumber;
const int Realloc::kNFieldNumber;
const int Realloc::kRetFieldNumber;
#endif  // !_MSC_VER

Realloc::Realloc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Realloc::InitAsDefaultInstance() {
}

Realloc::Realloc(const Realloc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Realloc::SharedCtor() {
  _cached_size_ = 0;
  p_ = GOOGLE_ULONGLONG(0);
  n_ = GOOGLE_ULONGLONG(0);
  ret_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Realloc::~Realloc() {
  SharedDtor();
}

void Realloc::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Realloc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Realloc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Realloc_descriptor_;
}

const Realloc& Realloc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Realloc* Realloc::default_instance_ = NULL;

Realloc* Realloc::New() const {
  return new Realloc;
}

void Realloc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    p_ = GOOGLE_ULONGLONG(0);
    n_ = GOOGLE_ULONGLONG(0);
    ret_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Realloc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 p = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &p_)));
          set_has_p();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_n;
        break;
      }
      
      // required uint64 n = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &n_)));
          set_has_n();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ret;
        break;
      }
      
      // required uint64 ret = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Realloc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 p = 1;
  if (has_p()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->p(), output);
  }
  
  // required uint64 n = 2;
  if (has_n()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->n(), output);
  }
  
  // required uint64 ret = 3;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->ret(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Realloc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 p = 1;
  if (has_p()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->p(), target);
  }
  
  // required uint64 n = 2;
  if (has_n()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->n(), target);
  }
  
  // required uint64 ret = 3;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->ret(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Realloc::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 p = 1;
    if (has_p()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->p());
    }
    
    // required uint64 n = 2;
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->n());
    }
    
    // required uint64 ret = 3;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ret());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Realloc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Realloc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Realloc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Realloc::MergeFrom(const Realloc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_p()) {
      set_p(from.p());
    }
    if (from.has_n()) {
      set_n(from.n());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Realloc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Realloc::CopyFrom(const Realloc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Realloc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Realloc::Swap(Realloc* other) {
  if (other != this) {
    std::swap(p_, other->p_);
    std::swap(n_, other->n_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Realloc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Realloc_descriptor_;
  metadata.reflection = Realloc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeapOperation::kMallocFieldNumber;
const int HeapOperation::kFreeFieldNumber;
const int HeapOperation::kReallocFieldNumber;
#endif  // !_MSC_VER

HeapOperation::HeapOperation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HeapOperation::InitAsDefaultInstance() {
  malloc_ = const_cast< ::ztrace::Malloc*>(&::ztrace::Malloc::default_instance());
  free_ = const_cast< ::ztrace::Free*>(&::ztrace::Free::default_instance());
  realloc_ = const_cast< ::ztrace::Realloc*>(&::ztrace::Realloc::default_instance());
}

HeapOperation::HeapOperation(const HeapOperation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HeapOperation::SharedCtor() {
  _cached_size_ = 0;
  malloc_ = NULL;
  free_ = NULL;
  realloc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeapOperation::~HeapOperation() {
  SharedDtor();
}

void HeapOperation::SharedDtor() {
  if (this != default_instance_) {
    delete malloc_;
    delete free_;
    delete realloc_;
  }
}

void HeapOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeapOperation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeapOperation_descriptor_;
}

const HeapOperation& HeapOperation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

HeapOperation* HeapOperation::default_instance_ = NULL;

HeapOperation* HeapOperation::New() const {
  return new HeapOperation;
}

void HeapOperation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_malloc()) {
      if (malloc_ != NULL) malloc_->::ztrace::Malloc::Clear();
    }
    if (has_free()) {
      if (free_ != NULL) free_->::ztrace::Free::Clear();
    }
    if (has_realloc()) {
      if (realloc_ != NULL) realloc_->::ztrace::Realloc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeapOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ztrace.Malloc malloc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_malloc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_free;
        break;
      }
      
      // optional .ztrace.Free free = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_free:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_free()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_realloc;
        break;
      }
      
      // optional .ztrace.Realloc realloc = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_realloc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_realloc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeapOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ztrace.Malloc malloc = 1;
  if (has_malloc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->malloc(), output);
  }
  
  // optional .ztrace.Free free = 2;
  if (has_free()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->free(), output);
  }
  
  // optional .ztrace.Realloc realloc = 3;
  if (has_realloc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->realloc(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HeapOperation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ztrace.Malloc malloc = 1;
  if (has_malloc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->malloc(), target);
  }
  
  // optional .ztrace.Free free = 2;
  if (has_free()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->free(), target);
  }
  
  // optional .ztrace.Realloc realloc = 3;
  if (has_realloc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->realloc(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HeapOperation::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ztrace.Malloc malloc = 1;
    if (has_malloc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->malloc());
    }
    
    // optional .ztrace.Free free = 2;
    if (has_free()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->free());
    }
    
    // optional .ztrace.Realloc realloc = 3;
    if (has_realloc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->realloc());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeapOperation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeapOperation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeapOperation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeapOperation::MergeFrom(const HeapOperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_malloc()) {
      mutable_malloc()->::ztrace::Malloc::MergeFrom(from.malloc());
    }
    if (from.has_free()) {
      mutable_free()->::ztrace::Free::MergeFrom(from.free());
    }
    if (from.has_realloc()) {
      mutable_realloc()->::ztrace::Realloc::MergeFrom(from.realloc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeapOperation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeapOperation::CopyFrom(const HeapOperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeapOperation::IsInitialized() const {
  
  if (has_malloc()) {
    if (!this->malloc().IsInitialized()) return false;
  }
  if (has_free()) {
    if (!this->free().IsInitialized()) return false;
  }
  if (has_realloc()) {
    if (!this->realloc().IsInitialized()) return false;
  }
  return true;
}

void HeapOperation::Swap(HeapOperation* other) {
  if (other != this) {
    std::swap(malloc_, other->malloc_);
    std::swap(free_, other->free_);
    std::swap(realloc_, other->realloc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeapOperation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeapOperation_descriptor_;
  metadata.reflection = HeapOperation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Value::kVUint64FieldNumber;
const int Value::kVInt64FieldNumber;
#endif  // !_MSC_VER

Value::Value()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Value::InitAsDefaultInstance() {
}

Value::Value(const Value& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Value::SharedCtor() {
  _cached_size_ = 0;
  v_uint64_ = GOOGLE_ULONGLONG(0);
  v_int64_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value::~Value() {
  SharedDtor();
}

void Value::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_descriptor_;
}

const Value& Value::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Value* Value::default_instance_ = NULL;

Value* Value::New() const {
  return new Value;
}

void Value::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    v_uint64_ = GOOGLE_ULONGLONG(0);
    v_int64_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 v_uint64 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &v_uint64_)));
          set_has_v_uint64();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_v_int64;
        break;
      }
      
      // optional int64 v_int64 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_v_int64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &v_int64_)));
          set_has_v_int64();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 v_uint64 = 1;
  if (has_v_uint64()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->v_uint64(), output);
  }
  
  // optional int64 v_int64 = 2;
  if (has_v_int64()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->v_int64(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Value::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 v_uint64 = 1;
  if (has_v_uint64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->v_uint64(), target);
  }
  
  // optional int64 v_int64 = 2;
  if (has_v_int64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->v_int64(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Value::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 v_uint64 = 1;
    if (has_v_uint64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->v_uint64());
    }
    
    // optional int64 v_int64 = 2;
    if (has_v_int64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->v_int64());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value::MergeFrom(const Value& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_v_uint64()) {
      set_v_uint64(from.v_uint64());
    }
    if (from.has_v_int64()) {
      set_v_int64(from.v_int64());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value::CopyFrom(const Value& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {
  
  return true;
}

void Value::Swap(Value* other) {
  if (other != this) {
    std::swap(v_uint64_, other->v_uint64_);
    std::swap(v_int64_, other->v_int64_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_descriptor_;
  metadata.reflection = Value_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FunctionArgument::kValueFieldNumber;
#endif  // !_MSC_VER

FunctionArgument::FunctionArgument()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FunctionArgument::InitAsDefaultInstance() {
  value_ = const_cast< ::ztrace::Value*>(&::ztrace::Value::default_instance());
}

FunctionArgument::FunctionArgument(const FunctionArgument& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FunctionArgument::SharedCtor() {
  _cached_size_ = 0;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FunctionArgument::~FunctionArgument() {
  SharedDtor();
}

void FunctionArgument::SharedDtor() {
  if (this != default_instance_) {
    delete value_;
  }
}

void FunctionArgument::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FunctionArgument::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionArgument_descriptor_;
}

const FunctionArgument& FunctionArgument::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

FunctionArgument* FunctionArgument::default_instance_ = NULL;

FunctionArgument* FunctionArgument::New() const {
  return new FunctionArgument;
}

void FunctionArgument::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_value()) {
      if (value_ != NULL) value_->::ztrace::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FunctionArgument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ztrace.Value value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FunctionArgument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ztrace.Value value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->value(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FunctionArgument::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ztrace.Value value = 1;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->value(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FunctionArgument::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ztrace.Value value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FunctionArgument::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FunctionArgument* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FunctionArgument*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FunctionArgument::MergeFrom(const FunctionArgument& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      mutable_value()->::ztrace::Value::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FunctionArgument::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FunctionArgument::CopyFrom(const FunctionArgument& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionArgument::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void FunctionArgument::Swap(FunctionArgument* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FunctionArgument::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FunctionArgument_descriptor_;
  metadata.reflection = FunctionArgument_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FunctionCall::kNameFieldNumber;
const int FunctionCall::kModuleIdFieldNumber;
const int FunctionCall::kRetFieldNumber;
const int FunctionCall::kArgFieldNumber;
#endif  // !_MSC_VER

FunctionCall::FunctionCall()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FunctionCall::InitAsDefaultInstance() {
  ret_ = const_cast< ::ztrace::Value*>(&::ztrace::Value::default_instance());
}

FunctionCall::FunctionCall(const FunctionCall& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FunctionCall::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  module_id_ = 0u;
  ret_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FunctionCall::~FunctionCall() {
  SharedDtor();
}

void FunctionCall::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete ret_;
  }
}

void FunctionCall::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FunctionCall::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionCall_descriptor_;
}

const FunctionCall& FunctionCall::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

FunctionCall* FunctionCall::default_instance_ = NULL;

FunctionCall* FunctionCall::New() const {
  return new FunctionCall;
}

void FunctionCall::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    module_id_ = 0u;
    if (has_ret()) {
      if (ret_ != NULL) ret_->::ztrace::Value::Clear();
    }
  }
  arg_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FunctionCall::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_module_id;
        break;
      }
      
      // required uint32 module_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_module_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &module_id_)));
          set_has_module_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ret;
        break;
      }
      
      // optional .ztrace.Value ret = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ret()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_arg;
        break;
      }
      
      // repeated .ztrace.Value arg = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_arg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_arg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_arg;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FunctionCall::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required uint32 module_id = 2;
  if (has_module_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->module_id(), output);
  }
  
  // optional .ztrace.Value ret = 3;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->ret(), output);
  }
  
  // repeated .ztrace.Value arg = 4;
  for (int i = 0; i < this->arg_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->arg(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FunctionCall::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required uint32 module_id = 2;
  if (has_module_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->module_id(), target);
  }
  
  // optional .ztrace.Value ret = 3;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->ret(), target);
  }
  
  // repeated .ztrace.Value arg = 4;
  for (int i = 0; i < this->arg_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->arg(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FunctionCall::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required uint32 module_id = 2;
    if (has_module_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->module_id());
    }
    
    // optional .ztrace.Value ret = 3;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ret());
    }
    
  }
  // repeated .ztrace.Value arg = 4;
  total_size += 1 * this->arg_size();
  for (int i = 0; i < this->arg_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->arg(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FunctionCall::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FunctionCall* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FunctionCall*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FunctionCall::MergeFrom(const FunctionCall& from) {
  GOOGLE_CHECK_NE(&from, this);
  arg_.MergeFrom(from.arg_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_module_id()) {
      set_module_id(from.module_id());
    }
    if (from.has_ret()) {
      mutable_ret()->::ztrace::Value::MergeFrom(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FunctionCall::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FunctionCall::CopyFrom(const FunctionCall& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionCall::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void FunctionCall::Swap(FunctionCall* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(module_id_, other->module_id_);
    std::swap(ret_, other->ret_);
    arg_.Swap(&other->arg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FunctionCall::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FunctionCall_descriptor_;
  metadata.reflection = FunctionCall_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ThreadStart::kFlagsFieldNumber;
#endif  // !_MSC_VER

ThreadStart::ThreadStart()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ThreadStart::InitAsDefaultInstance() {
}

ThreadStart::ThreadStart(const ThreadStart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ThreadStart::SharedCtor() {
  _cached_size_ = 0;
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreadStart::~ThreadStart() {
  SharedDtor();
}

void ThreadStart::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ThreadStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ThreadStart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ThreadStart_descriptor_;
}

const ThreadStart& ThreadStart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

ThreadStart* ThreadStart::default_instance_ = NULL;

ThreadStart* ThreadStart::New() const {
  return new ThreadStart;
}

void ThreadStart::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flags_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ThreadStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 flags = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ThreadStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 flags = 1;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->flags(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ThreadStart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 flags = 1;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->flags(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ThreadStart::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 flags = 1;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreadStart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ThreadStart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ThreadStart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ThreadStart::MergeFrom(const ThreadStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ThreadStart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThreadStart::CopyFrom(const ThreadStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreadStart::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ThreadStart::Swap(ThreadStart* other) {
  if (other != this) {
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ThreadStart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ThreadStart_descriptor_;
  metadata.reflection = ThreadStart_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ThreadEnd::kFlagsFieldNumber;
#endif  // !_MSC_VER

ThreadEnd::ThreadEnd()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ThreadEnd::InitAsDefaultInstance() {
}

ThreadEnd::ThreadEnd(const ThreadEnd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ThreadEnd::SharedCtor() {
  _cached_size_ = 0;
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreadEnd::~ThreadEnd() {
  SharedDtor();
}

void ThreadEnd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ThreadEnd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ThreadEnd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ThreadEnd_descriptor_;
}

const ThreadEnd& ThreadEnd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

ThreadEnd* ThreadEnd::default_instance_ = NULL;

ThreadEnd* ThreadEnd::New() const {
  return new ThreadEnd;
}

void ThreadEnd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flags_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ThreadEnd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 flags = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ThreadEnd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 flags = 2;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->flags(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ThreadEnd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 flags = 2;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->flags(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ThreadEnd::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 flags = 2;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreadEnd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ThreadEnd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ThreadEnd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ThreadEnd::MergeFrom(const ThreadEnd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ThreadEnd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThreadEnd::CopyFrom(const ThreadEnd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreadEnd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ThreadEnd::Swap(ThreadEnd* other) {
  if (other != this) {
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ThreadEnd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ThreadEnd_descriptor_;
  metadata.reflection = ThreadEnd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Timestamp::kSecFieldNumber;
const int Timestamp::kUsecFieldNumber;
#endif  // !_MSC_VER

Timestamp::Timestamp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Timestamp::InitAsDefaultInstance() {
}

Timestamp::Timestamp(const Timestamp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Timestamp::SharedCtor() {
  _cached_size_ = 0;
  sec_ = 0u;
  usec_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Timestamp::~Timestamp() {
  SharedDtor();
}

void Timestamp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Timestamp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Timestamp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Timestamp_descriptor_;
}

const Timestamp& Timestamp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Timestamp* Timestamp::default_instance_ = NULL;

Timestamp* Timestamp::New() const {
  return new Timestamp;
}

void Timestamp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sec_ = 0u;
    usec_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Timestamp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sec = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sec_)));
          set_has_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_usec;
        break;
      }
      
      // required uint32 usec = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_usec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &usec_)));
          set_has_usec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Timestamp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 sec = 1;
  if (has_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sec(), output);
  }
  
  // required uint32 usec = 2;
  if (has_usec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->usec(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Timestamp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 sec = 1;
  if (has_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sec(), target);
  }
  
  // required uint32 usec = 2;
  if (has_usec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->usec(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Timestamp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sec = 1;
    if (has_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sec());
    }
    
    // required uint32 usec = 2;
    if (has_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->usec());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Timestamp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Timestamp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Timestamp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Timestamp::MergeFrom(const Timestamp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sec()) {
      set_sec(from.sec());
    }
    if (from.has_usec()) {
      set_usec(from.usec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Timestamp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timestamp::CopyFrom(const Timestamp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Timestamp::Swap(Timestamp* other) {
  if (other != this) {
    std::swap(sec_, other->sec_);
    std::swap(usec_, other->usec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Timestamp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Timestamp_descriptor_;
  metadata.reflection = Timestamp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TraceStart::kTimestampFieldNumber;
const int TraceStart::kArchFieldNumber;
const int TraceStart::kSoftwareFieldNumber;
const int TraceStart::kTargetFieldNumber;
const int TraceStart::kCmdlineFieldNumber;
const int TraceStart::kOsUnameFieldNumber;
#endif  // !_MSC_VER

TraceStart::TraceStart()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TraceStart::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::ztrace::Timestamp*>(&::ztrace::Timestamp::default_instance());
}

TraceStart::TraceStart(const TraceStart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TraceStart::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  arch_ = 1;
  software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cmdline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  os_uname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceStart::~TraceStart() {
  SharedDtor();
}

void TraceStart::SharedDtor() {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    delete software_;
  }
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (cmdline_ != &::google::protobuf::internal::kEmptyString) {
    delete cmdline_;
  }
  if (os_uname_ != &::google::protobuf::internal::kEmptyString) {
    delete os_uname_;
  }
  if (this != default_instance_) {
    delete timestamp_;
  }
}

void TraceStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TraceStart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TraceStart_descriptor_;
}

const TraceStart& TraceStart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

TraceStart* TraceStart::default_instance_ = NULL;

TraceStart* TraceStart::New() const {
  return new TraceStart;
}

void TraceStart::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::ztrace::Timestamp::Clear();
    }
    arch_ = 1;
    if (has_software()) {
      if (software_ != &::google::protobuf::internal::kEmptyString) {
        software_->clear();
      }
    }
    if (has_target()) {
      if (target_ != &::google::protobuf::internal::kEmptyString) {
        target_->clear();
      }
    }
    if (has_cmdline()) {
      if (cmdline_ != &::google::protobuf::internal::kEmptyString) {
        cmdline_->clear();
      }
    }
    if (has_os_uname()) {
      if (os_uname_ != &::google::protobuf::internal::kEmptyString) {
        os_uname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TraceStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ztrace.Timestamp timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_arch;
        break;
      }
      
      // required .ztrace.Arch arch = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_arch:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (ztrace::Arch_IsValid(value)) {
            set_arch(static_cast< ztrace::Arch >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_software;
        break;
      }
      
      // optional string software = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_software:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_software()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->software().data(), this->software().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_target;
        break;
      }
      
      // optional string target = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_target()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->target().data(), this->target().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_cmdline;
        break;
      }
      
      // optional string cmdline = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cmdline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cmdline()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cmdline().data(), this->cmdline().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_os_uname;
        break;
      }
      
      // optional string os_uname = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_os_uname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_os_uname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->os_uname().data(), this->os_uname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TraceStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ztrace.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->timestamp(), output);
  }
  
  // required .ztrace.Arch arch = 2;
  if (has_arch()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->arch(), output);
  }
  
  // optional string software = 3;
  if (has_software()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->software().data(), this->software().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->software(), output);
  }
  
  // optional string target = 4;
  if (has_target()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target().data(), this->target().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->target(), output);
  }
  
  // optional string cmdline = 5;
  if (has_cmdline()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cmdline().data(), this->cmdline().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->cmdline(), output);
  }
  
  // optional string os_uname = 6;
  if (has_os_uname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->os_uname().data(), this->os_uname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->os_uname(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TraceStart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ztrace.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->timestamp(), target);
  }
  
  // required .ztrace.Arch arch = 2;
  if (has_arch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->arch(), target);
  }
  
  // optional string software = 3;
  if (has_software()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->software().data(), this->software().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->software(), target);
  }
  
  // optional string target = 4;
  if (has_target()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target().data(), this->target().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->target(), target);
  }
  
  // optional string cmdline = 5;
  if (has_cmdline()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cmdline().data(), this->cmdline().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->cmdline(), target);
  }
  
  // optional string os_uname = 6;
  if (has_os_uname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->os_uname().data(), this->os_uname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->os_uname(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TraceStart::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ztrace.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timestamp());
    }
    
    // required .ztrace.Arch arch = 2;
    if (has_arch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->arch());
    }
    
    // optional string software = 3;
    if (has_software()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->software());
    }
    
    // optional string target = 4;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->target());
    }
    
    // optional string cmdline = 5;
    if (has_cmdline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cmdline());
    }
    
    // optional string os_uname = 6;
    if (has_os_uname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->os_uname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceStart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TraceStart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TraceStart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TraceStart::MergeFrom(const TraceStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::ztrace::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_arch()) {
      set_arch(from.arch());
    }
    if (from.has_software()) {
      set_software(from.software());
    }
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_cmdline()) {
      set_cmdline(from.cmdline());
    }
    if (from.has_os_uname()) {
      set_os_uname(from.os_uname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TraceStart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TraceStart::CopyFrom(const TraceStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceStart::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_timestamp()) {
    if (!this->timestamp().IsInitialized()) return false;
  }
  return true;
}

void TraceStart::Swap(TraceStart* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(arch_, other->arch_);
    std::swap(software_, other->software_);
    std::swap(target_, other->target_);
    std::swap(cmdline_, other->cmdline_);
    std::swap(os_uname_, other->os_uname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TraceStart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TraceStart_descriptor_;
  metadata.reflection = TraceStart_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TraceEnd::kTimestampFieldNumber;
#endif  // !_MSC_VER

TraceEnd::TraceEnd()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TraceEnd::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::ztrace::Timestamp*>(&::ztrace::Timestamp::default_instance());
}

TraceEnd::TraceEnd(const TraceEnd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TraceEnd::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceEnd::~TraceEnd() {
  SharedDtor();
}

void TraceEnd::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
  }
}

void TraceEnd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TraceEnd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TraceEnd_descriptor_;
}

const TraceEnd& TraceEnd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

TraceEnd* TraceEnd::default_instance_ = NULL;

TraceEnd* TraceEnd::New() const {
  return new TraceEnd;
}

void TraceEnd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::ztrace::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TraceEnd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ztrace.Timestamp timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TraceEnd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ztrace.Timestamp timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->timestamp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TraceEnd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ztrace.Timestamp timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->timestamp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TraceEnd::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ztrace.Timestamp timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timestamp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceEnd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TraceEnd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TraceEnd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TraceEnd::MergeFrom(const TraceEnd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::ztrace::Timestamp::MergeFrom(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TraceEnd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TraceEnd::CopyFrom(const TraceEnd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceEnd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_timestamp()) {
    if (!this->timestamp().IsInitialized()) return false;
  }
  return true;
}

void TraceEnd::Swap(TraceEnd* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TraceEnd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TraceEnd_descriptor_;
  metadata.reflection = TraceEnd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MicroEventLogPtr::kTidFieldNumber;
const int MicroEventLogPtr::kNextInstructionFieldNumber;
#endif  // !_MSC_VER

MicroEventLogPtr::MicroEventLogPtr()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MicroEventLogPtr::InitAsDefaultInstance() {
}

MicroEventLogPtr::MicroEventLogPtr(const MicroEventLogPtr& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MicroEventLogPtr::SharedCtor() {
  _cached_size_ = 0;
  tid_ = 0u;
  next_instruction_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MicroEventLogPtr::~MicroEventLogPtr() {
  SharedDtor();
}

void MicroEventLogPtr::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MicroEventLogPtr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MicroEventLogPtr::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MicroEventLogPtr_descriptor_;
}

const MicroEventLogPtr& MicroEventLogPtr::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

MicroEventLogPtr* MicroEventLogPtr::default_instance_ = NULL;

MicroEventLogPtr* MicroEventLogPtr::New() const {
  return new MicroEventLogPtr;
}

void MicroEventLogPtr::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tid_ = 0u;
    next_instruction_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MicroEventLogPtr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 tid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tid_)));
          set_has_tid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_next_instruction;
        break;
      }
      
      // required uint32 next_instruction = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_next_instruction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_instruction_)));
          set_has_next_instruction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MicroEventLogPtr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 tid = 1;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tid(), output);
  }
  
  // required uint32 next_instruction = 2;
  if (has_next_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->next_instruction(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MicroEventLogPtr::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 tid = 1;
  if (has_tid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->tid(), target);
  }
  
  // required uint32 next_instruction = 2;
  if (has_next_instruction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->next_instruction(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MicroEventLogPtr::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 tid = 1;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tid());
    }
    
    // required uint32 next_instruction = 2;
    if (has_next_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_instruction());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MicroEventLogPtr::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MicroEventLogPtr* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MicroEventLogPtr*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MicroEventLogPtr::MergeFrom(const MicroEventLogPtr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tid()) {
      set_tid(from.tid());
    }
    if (from.has_next_instruction()) {
      set_next_instruction(from.next_instruction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MicroEventLogPtr::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MicroEventLogPtr::CopyFrom(const MicroEventLogPtr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MicroEventLogPtr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void MicroEventLogPtr::Swap(MicroEventLogPtr* other) {
  if (other != this) {
    std::swap(tid_, other->tid_);
    std::swap(next_instruction_, other->next_instruction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MicroEventLogPtr::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MicroEventLogPtr_descriptor_;
  metadata.reflection = MicroEventLogPtr_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Event::kIdFieldNumber;
const int Event::kPidFieldNumber;
const int Event::kTidFieldNumber;
const int Event::kCrossRefFieldNumber;
const int Event::kTraceStartFieldNumber;
const int Event::kTraceEndFieldNumber;
const int Event::kThreadStartFieldNumber;
const int Event::kThreadEndFieldNumber;
const int Event::kTraceDisasmFieldNumber;
const int Event::kModLoadFieldNumber;
const int Event::kModUnloadFieldNumber;
const int Event::kModSymbolsFieldNumber;
const int Event::kMicroEventLogFieldNumber;
const int Event::kMallocFieldNumber;
const int Event::kReallocFieldNumber;
const int Event::kFreeFieldNumber;
const int Event::kCallocFieldNumber;
#endif  // !_MSC_VER

Event::Event()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event::InitAsDefaultInstance() {
  trace_start_ = const_cast< ::ztrace::TraceStart*>(&::ztrace::TraceStart::default_instance());
  trace_end_ = const_cast< ::ztrace::TraceEnd*>(&::ztrace::TraceEnd::default_instance());
  thread_start_ = const_cast< ::ztrace::ThreadStart*>(&::ztrace::ThreadStart::default_instance());
  thread_end_ = const_cast< ::ztrace::ThreadEnd*>(&::ztrace::ThreadEnd::default_instance());
  trace_disasm_ = const_cast< ::ztrace::TraceDisassembly*>(&::ztrace::TraceDisassembly::default_instance());
  mod_load_ = const_cast< ::ztrace::ModuleLoad*>(&::ztrace::ModuleLoad::default_instance());
  mod_unload_ = const_cast< ::ztrace::ModuleUnload*>(&::ztrace::ModuleUnload::default_instance());
  mod_symbols_ = const_cast< ::ztrace::ModuleSymbols*>(&::ztrace::ModuleSymbols::default_instance());
  micro_event_log_ = const_cast< ::ztrace::MicroEventLog*>(&::ztrace::MicroEventLog::default_instance());
  malloc_ = const_cast< ::ztrace::Malloc*>(&::ztrace::Malloc::default_instance());
  realloc_ = const_cast< ::ztrace::Realloc*>(&::ztrace::Realloc::default_instance());
  free_ = const_cast< ::ztrace::Free*>(&::ztrace::Free::default_instance());
  calloc_ = const_cast< ::ztrace::Calloc*>(&::ztrace::Calloc::default_instance());
}

Event::Event(const Event& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  pid_ = 0u;
  tid_ = 0u;
  trace_start_ = NULL;
  trace_end_ = NULL;
  thread_start_ = NULL;
  thread_end_ = NULL;
  trace_disasm_ = NULL;
  mod_load_ = NULL;
  mod_unload_ = NULL;
  mod_symbols_ = NULL;
  micro_event_log_ = NULL;
  malloc_ = NULL;
  realloc_ = NULL;
  free_ = NULL;
  calloc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event::~Event() {
  SharedDtor();
}

void Event::SharedDtor() {
  if (this != default_instance_) {
    delete trace_start_;
    delete trace_end_;
    delete thread_start_;
    delete thread_end_;
    delete trace_disasm_;
    delete mod_load_;
    delete mod_unload_;
    delete mod_symbols_;
    delete micro_event_log_;
    delete malloc_;
    delete realloc_;
    delete free_;
    delete calloc_;
  }
}

void Event::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_descriptor_;
}

const Event& Event::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ZTrace_2eproto();  return *default_instance_;
}

Event* Event::default_instance_ = NULL;

Event* Event::New() const {
  return new Event;
}

void Event::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    pid_ = 0u;
    tid_ = 0u;
    if (has_trace_start()) {
      if (trace_start_ != NULL) trace_start_->::ztrace::TraceStart::Clear();
    }
    if (has_trace_end()) {
      if (trace_end_ != NULL) trace_end_->::ztrace::TraceEnd::Clear();
    }
    if (has_thread_start()) {
      if (thread_start_ != NULL) thread_start_->::ztrace::ThreadStart::Clear();
    }
    if (has_thread_end()) {
      if (thread_end_ != NULL) thread_end_->::ztrace::ThreadEnd::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_trace_disasm()) {
      if (trace_disasm_ != NULL) trace_disasm_->::ztrace::TraceDisassembly::Clear();
    }
    if (has_mod_load()) {
      if (mod_load_ != NULL) mod_load_->::ztrace::ModuleLoad::Clear();
    }
    if (has_mod_unload()) {
      if (mod_unload_ != NULL) mod_unload_->::ztrace::ModuleUnload::Clear();
    }
    if (has_mod_symbols()) {
      if (mod_symbols_ != NULL) mod_symbols_->::ztrace::ModuleSymbols::Clear();
    }
    if (has_micro_event_log()) {
      if (micro_event_log_ != NULL) micro_event_log_->::ztrace::MicroEventLog::Clear();
    }
    if (has_malloc()) {
      if (malloc_ != NULL) malloc_->::ztrace::Malloc::Clear();
    }
    if (has_realloc()) {
      if (realloc_ != NULL) realloc_->::ztrace::Realloc::Clear();
    }
    if (has_free()) {
      if (free_ != NULL) free_->::ztrace::Free::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_calloc()) {
      if (calloc_ != NULL) calloc_->::ztrace::Calloc::Clear();
    }
  }
  cross_ref_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pid;
        break;
      }
      
      // required uint32 pid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_tid;
        break;
      }
      
      // required uint32 tid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tid_)));
          set_has_tid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_trace_start;
        break;
      }
      
      // optional .ztrace.TraceStart trace_start = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trace_start:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_start()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_trace_end;
        break;
      }
      
      // optional .ztrace.TraceEnd trace_end = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trace_end:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_end()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_thread_start;
        break;
      }
      
      // optional .ztrace.ThreadStart thread_start = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_thread_start:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_thread_start()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_thread_end;
        break;
      }
      
      // optional .ztrace.ThreadEnd thread_end = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_thread_end:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_thread_end()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_trace_disasm;
        break;
      }
      
      // optional .ztrace.TraceDisassembly trace_disasm = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trace_disasm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_disasm()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_mod_load;
        break;
      }
      
      // optional .ztrace.ModuleLoad mod_load = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mod_load:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mod_load()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(330)) goto parse_mod_unload;
        break;
      }
      
      // optional .ztrace.ModuleUnload mod_unload = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mod_unload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mod_unload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(338)) goto parse_mod_symbols;
        break;
      }
      
      // optional .ztrace.ModuleSymbols mod_symbols = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mod_symbols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mod_symbols()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_micro_event_log;
        break;
      }
      
      // optional .ztrace.MicroEventLog micro_event_log = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_micro_event_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_micro_event_log()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(482)) goto parse_malloc;
        break;
      }
      
      // optional .ztrace.Malloc malloc = 60;
      case 60: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_malloc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_malloc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(490)) goto parse_realloc;
        break;
      }
      
      // optional .ztrace.Realloc realloc = 61;
      case 61: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_realloc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_realloc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(498)) goto parse_free;
        break;
      }
      
      // optional .ztrace.Free free = 62;
      case 62: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_free:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_free()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(506)) goto parse_calloc;
        break;
      }
      
      // optional .ztrace.Calloc calloc = 63;
      case 63: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_calloc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_calloc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(802)) goto parse_cross_ref;
        break;
      }
      
      // repeated .ztrace.MicroEventLogPtr cross_ref = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cross_ref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cross_ref()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(802)) goto parse_cross_ref;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  // required uint32 pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->pid(), output);
  }
  
  // required uint32 tid = 3;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->tid(), output);
  }
  
  // optional .ztrace.TraceStart trace_start = 10;
  if (has_trace_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->trace_start(), output);
  }
  
  // optional .ztrace.TraceEnd trace_end = 11;
  if (has_trace_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->trace_end(), output);
  }
  
  // optional .ztrace.ThreadStart thread_start = 20;
  if (has_thread_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->thread_start(), output);
  }
  
  // optional .ztrace.ThreadEnd thread_end = 21;
  if (has_thread_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->thread_end(), output);
  }
  
  // optional .ztrace.TraceDisassembly trace_disasm = 30;
  if (has_trace_disasm()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, this->trace_disasm(), output);
  }
  
  // optional .ztrace.ModuleLoad mod_load = 40;
  if (has_mod_load()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      40, this->mod_load(), output);
  }
  
  // optional .ztrace.ModuleUnload mod_unload = 41;
  if (has_mod_unload()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      41, this->mod_unload(), output);
  }
  
  // optional .ztrace.ModuleSymbols mod_symbols = 42;
  if (has_mod_symbols()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      42, this->mod_symbols(), output);
  }
  
  // optional .ztrace.MicroEventLog micro_event_log = 50;
  if (has_micro_event_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      50, this->micro_event_log(), output);
  }
  
  // optional .ztrace.Malloc malloc = 60;
  if (has_malloc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      60, this->malloc(), output);
  }
  
  // optional .ztrace.Realloc realloc = 61;
  if (has_realloc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      61, this->realloc(), output);
  }
  
  // optional .ztrace.Free free = 62;
  if (has_free()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      62, this->free(), output);
  }
  
  // optional .ztrace.Calloc calloc = 63;
  if (has_calloc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      63, this->calloc(), output);
  }
  
  // repeated .ztrace.MicroEventLogPtr cross_ref = 100;
  for (int i = 0; i < this->cross_ref_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, this->cross_ref(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  // required uint32 pid = 2;
  if (has_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->pid(), target);
  }
  
  // required uint32 tid = 3;
  if (has_tid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->tid(), target);
  }
  
  // optional .ztrace.TraceStart trace_start = 10;
  if (has_trace_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->trace_start(), target);
  }
  
  // optional .ztrace.TraceEnd trace_end = 11;
  if (has_trace_end()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->trace_end(), target);
  }
  
  // optional .ztrace.ThreadStart thread_start = 20;
  if (has_thread_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->thread_start(), target);
  }
  
  // optional .ztrace.ThreadEnd thread_end = 21;
  if (has_thread_end()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->thread_end(), target);
  }
  
  // optional .ztrace.TraceDisassembly trace_disasm = 30;
  if (has_trace_disasm()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        30, this->trace_disasm(), target);
  }
  
  // optional .ztrace.ModuleLoad mod_load = 40;
  if (has_mod_load()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        40, this->mod_load(), target);
  }
  
  // optional .ztrace.ModuleUnload mod_unload = 41;
  if (has_mod_unload()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        41, this->mod_unload(), target);
  }
  
  // optional .ztrace.ModuleSymbols mod_symbols = 42;
  if (has_mod_symbols()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        42, this->mod_symbols(), target);
  }
  
  // optional .ztrace.MicroEventLog micro_event_log = 50;
  if (has_micro_event_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        50, this->micro_event_log(), target);
  }
  
  // optional .ztrace.Malloc malloc = 60;
  if (has_malloc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        60, this->malloc(), target);
  }
  
  // optional .ztrace.Realloc realloc = 61;
  if (has_realloc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        61, this->realloc(), target);
  }
  
  // optional .ztrace.Free free = 62;
  if (has_free()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        62, this->free(), target);
  }
  
  // optional .ztrace.Calloc calloc = 63;
  if (has_calloc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        63, this->calloc(), target);
  }
  
  // repeated .ztrace.MicroEventLogPtr cross_ref = 100;
  for (int i = 0; i < this->cross_ref_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        100, this->cross_ref(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
    // required uint32 pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pid());
    }
    
    // required uint32 tid = 3;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tid());
    }
    
    // optional .ztrace.TraceStart trace_start = 10;
    if (has_trace_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->trace_start());
    }
    
    // optional .ztrace.TraceEnd trace_end = 11;
    if (has_trace_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->trace_end());
    }
    
    // optional .ztrace.ThreadStart thread_start = 20;
    if (has_thread_start()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->thread_start());
    }
    
    // optional .ztrace.ThreadEnd thread_end = 21;
    if (has_thread_end()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->thread_end());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .ztrace.TraceDisassembly trace_disasm = 30;
    if (has_trace_disasm()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->trace_disasm());
    }
    
    // optional .ztrace.ModuleLoad mod_load = 40;
    if (has_mod_load()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mod_load());
    }
    
    // optional .ztrace.ModuleUnload mod_unload = 41;
    if (has_mod_unload()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mod_unload());
    }
    
    // optional .ztrace.ModuleSymbols mod_symbols = 42;
    if (has_mod_symbols()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mod_symbols());
    }
    
    // optional .ztrace.MicroEventLog micro_event_log = 50;
    if (has_micro_event_log()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->micro_event_log());
    }
    
    // optional .ztrace.Malloc malloc = 60;
    if (has_malloc()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->malloc());
    }
    
    // optional .ztrace.Realloc realloc = 61;
    if (has_realloc()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->realloc());
    }
    
    // optional .ztrace.Free free = 62;
    if (has_free()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->free());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .ztrace.Calloc calloc = 63;
    if (has_calloc()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->calloc());
    }
    
  }
  // repeated .ztrace.MicroEventLogPtr cross_ref = 100;
  total_size += 2 * this->cross_ref_size();
  for (int i = 0; i < this->cross_ref_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cross_ref(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event::MergeFrom(const Event& from) {
  GOOGLE_CHECK_NE(&from, this);
  cross_ref_.MergeFrom(from.cross_ref_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_tid()) {
      set_tid(from.tid());
    }
    if (from.has_trace_start()) {
      mutable_trace_start()->::ztrace::TraceStart::MergeFrom(from.trace_start());
    }
    if (from.has_trace_end()) {
      mutable_trace_end()->::ztrace::TraceEnd::MergeFrom(from.trace_end());
    }
    if (from.has_thread_start()) {
      mutable_thread_start()->::ztrace::ThreadStart::MergeFrom(from.thread_start());
    }
    if (from.has_thread_end()) {
      mutable_thread_end()->::ztrace::ThreadEnd::MergeFrom(from.thread_end());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_trace_disasm()) {
      mutable_trace_disasm()->::ztrace::TraceDisassembly::MergeFrom(from.trace_disasm());
    }
    if (from.has_mod_load()) {
      mutable_mod_load()->::ztrace::ModuleLoad::MergeFrom(from.mod_load());
    }
    if (from.has_mod_unload()) {
      mutable_mod_unload()->::ztrace::ModuleUnload::MergeFrom(from.mod_unload());
    }
    if (from.has_mod_symbols()) {
      mutable_mod_symbols()->::ztrace::ModuleSymbols::MergeFrom(from.mod_symbols());
    }
    if (from.has_micro_event_log()) {
      mutable_micro_event_log()->::ztrace::MicroEventLog::MergeFrom(from.micro_event_log());
    }
    if (from.has_malloc()) {
      mutable_malloc()->::ztrace::Malloc::MergeFrom(from.malloc());
    }
    if (from.has_realloc()) {
      mutable_realloc()->::ztrace::Realloc::MergeFrom(from.realloc());
    }
    if (from.has_free()) {
      mutable_free()->::ztrace::Free::MergeFrom(from.free());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_calloc()) {
      mutable_calloc()->::ztrace::Calloc::MergeFrom(from.calloc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event::CopyFrom(const Event& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < cross_ref_size(); i++) {
    if (!this->cross_ref(i).IsInitialized()) return false;
  }
  if (has_trace_start()) {
    if (!this->trace_start().IsInitialized()) return false;
  }
  if (has_trace_end()) {
    if (!this->trace_end().IsInitialized()) return false;
  }
  if (has_thread_start()) {
    if (!this->thread_start().IsInitialized()) return false;
  }
  if (has_thread_end()) {
    if (!this->thread_end().IsInitialized()) return false;
  }
  if (has_trace_disasm()) {
    if (!this->trace_disasm().IsInitialized()) return false;
  }
  if (has_mod_load()) {
    if (!this->mod_load().IsInitialized()) return false;
  }
  if (has_mod_unload()) {
    if (!this->mod_unload().IsInitialized()) return false;
  }
  if (has_mod_symbols()) {
    if (!this->mod_symbols().IsInitialized()) return false;
  }
  if (has_micro_event_log()) {
    if (!this->micro_event_log().IsInitialized()) return false;
  }
  if (has_malloc()) {
    if (!this->malloc().IsInitialized()) return false;
  }
  if (has_realloc()) {
    if (!this->realloc().IsInitialized()) return false;
  }
  if (has_free()) {
    if (!this->free().IsInitialized()) return false;
  }
  if (has_calloc()) {
    if (!this->calloc().IsInitialized()) return false;
  }
  return true;
}

void Event::Swap(Event* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(pid_, other->pid_);
    std::swap(tid_, other->tid_);
    cross_ref_.Swap(&other->cross_ref_);
    std::swap(trace_start_, other->trace_start_);
    std::swap(trace_end_, other->trace_end_);
    std::swap(thread_start_, other->thread_start_);
    std::swap(thread_end_, other->thread_end_);
    std::swap(trace_disasm_, other->trace_disasm_);
    std::swap(mod_load_, other->mod_load_);
    std::swap(mod_unload_, other->mod_unload_);
    std::swap(mod_symbols_, other->mod_symbols_);
    std::swap(micro_event_log_, other->micro_event_log_);
    std::swap(malloc_, other->malloc_);
    std::swap(realloc_, other->realloc_);
    std::swap(free_, other->free_);
    std::swap(calloc_, other->calloc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_descriptor_;
  metadata.reflection = Event_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ztrace

// @@protoc_insertion_point(global_scope)
