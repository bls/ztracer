// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZTrace.proto

#ifndef PROTOBUF_ZTrace_2eproto__INCLUDED
#define PROTOBUF_ZTrace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Registers.pb.h"
// @@protoc_insertion_point(includes)

namespace ztrace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ZTrace_2eproto();
void protobuf_AssignDesc_ZTrace_2eproto();
void protobuf_ShutdownFile_ZTrace_2eproto();

class MicroEventLog;
class InsDisassembly;
class BBLDisassembly;
class TraceDisassembly;
class Section;
class ModuleLoad;
class ModuleUnload;
class SymbolEntry;
class ModuleSymbols;
class Malloc;
class Calloc;
class Free;
class Realloc;
class HeapOperation;
class Value;
class FunctionArgument;
class FunctionCall;
class ThreadStart;
class ThreadEnd;
class Timestamp;
class TraceStart;
class TraceEnd;
class MicroEventLogPtr;
class Event;

enum Section_SectionType {
  Section_SectionType_SEC_TYPE_INVALID = 0,
  Section_SectionType_SEC_TYPE_UNUSED = 1,
  Section_SectionType_SEC_TYPE_REGREL = 2,
  Section_SectionType_SEC_TYPE_DYNREL = 3,
  Section_SectionType_SEC_TYPE_EXEC = 4,
  Section_SectionType_SEC_TYPE_DATA = 5,
  Section_SectionType_SEC_TYPE_DYNAMIC = 6,
  Section_SectionType_SEC_TYPE_OPD = 7,
  Section_SectionType_SEC_TYPE_GOT = 8,
  Section_SectionType_SEC_TYPE_STACK = 9,
  Section_SectionType_SEC_TYPE_PLTOFF = 10,
  Section_SectionType_SEC_TYPE_HASH = 11,
  Section_SectionType_SEC_TYPE_LSDA = 12,
  Section_SectionType_SEC_TYPE_UNWIND = 13,
  Section_SectionType_SEC_TYPE_UNWINDINFO = 14,
  Section_SectionType_SEC_TYPE_REGSYM = 15,
  Section_SectionType_SEC_TYPE_DYNSYM = 16,
  Section_SectionType_SEC_TYPE_DEBUG = 17,
  Section_SectionType_SEC_TYPE_BSS = 18,
  Section_SectionType_SEC_TYPE_SYMSTR = 19,
  Section_SectionType_SEC_TYPE_DYNSTR = 20,
  Section_SectionType_SEC_TYPE_SECSTR = 21,
  Section_SectionType_SEC_TYPE_COMMENT = 22,
  Section_SectionType_SEC_TYPE_LOOS = 23,
  Section_SectionType_SEC_TYPE_USER = 24,
  Section_SectionType_SEC_TYPE_UNKNOWN = 999
};
bool Section_SectionType_IsValid(int value);
const Section_SectionType Section_SectionType_SectionType_MIN = Section_SectionType_SEC_TYPE_INVALID;
const Section_SectionType Section_SectionType_SectionType_MAX = Section_SectionType_SEC_TYPE_UNKNOWN;
const int Section_SectionType_SectionType_ARRAYSIZE = Section_SectionType_SectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Section_SectionType_descriptor();
inline const ::std::string& Section_SectionType_Name(Section_SectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Section_SectionType_descriptor(), value);
}
inline bool Section_SectionType_Parse(
    const ::std::string& name, Section_SectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Section_SectionType>(
    Section_SectionType_descriptor(), name, value);
}
enum ModuleLoad_ImageType {
  ModuleLoad_ImageType_IMG_TYPE_INVALID = 0,
  ModuleLoad_ImageType_IMG_TYPE_STATIC = 1,
  ModuleLoad_ImageType_IMG_TYPE_SHARED = 2,
  ModuleLoad_ImageType_IMG_TYPE_SHAREDLIB = 3,
  ModuleLoad_ImageType_IMG_TYPE_RELOCATABLE = 4,
  ModuleLoad_ImageType_IMG_TYPE_UNKNOWN = 999
};
bool ModuleLoad_ImageType_IsValid(int value);
const ModuleLoad_ImageType ModuleLoad_ImageType_ImageType_MIN = ModuleLoad_ImageType_IMG_TYPE_INVALID;
const ModuleLoad_ImageType ModuleLoad_ImageType_ImageType_MAX = ModuleLoad_ImageType_IMG_TYPE_UNKNOWN;
const int ModuleLoad_ImageType_ImageType_ARRAYSIZE = ModuleLoad_ImageType_ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModuleLoad_ImageType_descriptor();
inline const ::std::string& ModuleLoad_ImageType_Name(ModuleLoad_ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModuleLoad_ImageType_descriptor(), value);
}
inline bool ModuleLoad_ImageType_Parse(
    const ::std::string& name, ModuleLoad_ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModuleLoad_ImageType>(
    ModuleLoad_ImageType_descriptor(), name, value);
}
enum Arch {
  ARCH_X86 = 1,
  ARCH_X86_64 = 2
};
bool Arch_IsValid(int value);
const Arch Arch_MIN = ARCH_X86;
const Arch Arch_MAX = ARCH_X86_64;
const int Arch_ARRAYSIZE = Arch_MAX + 1;

const ::google::protobuf::EnumDescriptor* Arch_descriptor();
inline const ::std::string& Arch_Name(Arch value) {
  return ::google::protobuf::internal::NameOfEnum(
    Arch_descriptor(), value);
}
inline bool Arch_Parse(
    const ::std::string& name, Arch* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Arch>(
    Arch_descriptor(), name, value);
}
// ===================================================================

class MicroEventLog : public ::google::protobuf::Message {
 public:
  MicroEventLog();
  virtual ~MicroEventLog();
  
  MicroEventLog(const MicroEventLog& from);
  
  inline MicroEventLog& operator=(const MicroEventLog& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MicroEventLog& default_instance();
  
  void Swap(MicroEventLog* other);
  
  // implements Message ----------------------------------------------
  
  MicroEventLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MicroEventLog& from);
  void MergeFrom(const MicroEventLog& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 start_instruction = 1;
  inline bool has_start_instruction() const;
  inline void clear_start_instruction();
  static const int kStartInstructionFieldNumber = 1;
  inline ::google::protobuf::uint64 start_instruction() const;
  inline void set_start_instruction(::google::protobuf::uint64 value);
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:ztrace.MicroEventLog)
 private:
  inline void set_has_start_instruction();
  inline void clear_has_start_instruction();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 start_instruction_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static MicroEventLog* default_instance_;
};
// -------------------------------------------------------------------

class InsDisassembly : public ::google::protobuf::Message {
 public:
  InsDisassembly();
  virtual ~InsDisassembly();
  
  InsDisassembly(const InsDisassembly& from);
  
  inline InsDisassembly& operator=(const InsDisassembly& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsDisassembly& default_instance();
  
  void Swap(InsDisassembly* other);
  
  // implements Message ----------------------------------------------
  
  InsDisassembly* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsDisassembly& from);
  void MergeFrom(const InsDisassembly& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 pc = 1;
  inline bool has_pc() const;
  inline void clear_pc();
  static const int kPcFieldNumber = 1;
  inline ::google::protobuf::uint64 pc() const;
  inline void set_pc(::google::protobuf::uint64 value);
  
  // required string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional bytes raw_bytes = 3;
  inline bool has_raw_bytes() const;
  inline void clear_raw_bytes();
  static const int kRawBytesFieldNumber = 3;
  inline const ::std::string& raw_bytes() const;
  inline void set_raw_bytes(const ::std::string& value);
  inline void set_raw_bytes(const char* value);
  inline void set_raw_bytes(const void* value, size_t size);
  inline ::std::string* mutable_raw_bytes();
  inline ::std::string* release_raw_bytes();
  
  // @@protoc_insertion_point(class_scope:ztrace.InsDisassembly)
 private:
  inline void set_has_pc();
  inline void clear_has_pc();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_raw_bytes();
  inline void clear_has_raw_bytes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 pc_;
  ::std::string* text_;
  ::std::string* raw_bytes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static InsDisassembly* default_instance_;
};
// -------------------------------------------------------------------

class BBLDisassembly : public ::google::protobuf::Message {
 public:
  BBLDisassembly();
  virtual ~BBLDisassembly();
  
  BBLDisassembly(const BBLDisassembly& from);
  
  inline BBLDisassembly& operator=(const BBLDisassembly& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BBLDisassembly& default_instance();
  
  void Swap(BBLDisassembly* other);
  
  // implements Message ----------------------------------------------
  
  BBLDisassembly* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BBLDisassembly& from);
  void MergeFrom(const BBLDisassembly& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ztrace.InsDisassembly ins_disasm = 1;
  inline int ins_disasm_size() const;
  inline void clear_ins_disasm();
  static const int kInsDisasmFieldNumber = 1;
  inline const ::ztrace::InsDisassembly& ins_disasm(int index) const;
  inline ::ztrace::InsDisassembly* mutable_ins_disasm(int index);
  inline ::ztrace::InsDisassembly* add_ins_disasm();
  inline const ::google::protobuf::RepeatedPtrField< ::ztrace::InsDisassembly >&
      ins_disasm() const;
  inline ::google::protobuf::RepeatedPtrField< ::ztrace::InsDisassembly >*
      mutable_ins_disasm();
  
  // @@protoc_insertion_point(class_scope:ztrace.BBLDisassembly)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ztrace::InsDisassembly > ins_disasm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static BBLDisassembly* default_instance_;
};
// -------------------------------------------------------------------

class TraceDisassembly : public ::google::protobuf::Message {
 public:
  TraceDisassembly();
  virtual ~TraceDisassembly();
  
  TraceDisassembly(const TraceDisassembly& from);
  
  inline TraceDisassembly& operator=(const TraceDisassembly& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceDisassembly& default_instance();
  
  void Swap(TraceDisassembly* other);
  
  // implements Message ----------------------------------------------
  
  TraceDisassembly* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TraceDisassembly& from);
  void MergeFrom(const TraceDisassembly& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ztrace.BBLDisassembly bbl_disasm = 1;
  inline int bbl_disasm_size() const;
  inline void clear_bbl_disasm();
  static const int kBblDisasmFieldNumber = 1;
  inline const ::ztrace::BBLDisassembly& bbl_disasm(int index) const;
  inline ::ztrace::BBLDisassembly* mutable_bbl_disasm(int index);
  inline ::ztrace::BBLDisassembly* add_bbl_disasm();
  inline const ::google::protobuf::RepeatedPtrField< ::ztrace::BBLDisassembly >&
      bbl_disasm() const;
  inline ::google::protobuf::RepeatedPtrField< ::ztrace::BBLDisassembly >*
      mutable_bbl_disasm();
  
  // @@protoc_insertion_point(class_scope:ztrace.TraceDisassembly)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ztrace::BBLDisassembly > bbl_disasm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static TraceDisassembly* default_instance_;
};
// -------------------------------------------------------------------

class Section : public ::google::protobuf::Message {
 public:
  Section();
  virtual ~Section();
  
  Section(const Section& from);
  
  inline Section& operator=(const Section& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Section& default_instance();
  
  void Swap(Section* other);
  
  // implements Message ----------------------------------------------
  
  Section* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Section& from);
  void MergeFrom(const Section& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Section_SectionType SectionType;
  static const SectionType SEC_TYPE_INVALID = Section_SectionType_SEC_TYPE_INVALID;
  static const SectionType SEC_TYPE_UNUSED = Section_SectionType_SEC_TYPE_UNUSED;
  static const SectionType SEC_TYPE_REGREL = Section_SectionType_SEC_TYPE_REGREL;
  static const SectionType SEC_TYPE_DYNREL = Section_SectionType_SEC_TYPE_DYNREL;
  static const SectionType SEC_TYPE_EXEC = Section_SectionType_SEC_TYPE_EXEC;
  static const SectionType SEC_TYPE_DATA = Section_SectionType_SEC_TYPE_DATA;
  static const SectionType SEC_TYPE_DYNAMIC = Section_SectionType_SEC_TYPE_DYNAMIC;
  static const SectionType SEC_TYPE_OPD = Section_SectionType_SEC_TYPE_OPD;
  static const SectionType SEC_TYPE_GOT = Section_SectionType_SEC_TYPE_GOT;
  static const SectionType SEC_TYPE_STACK = Section_SectionType_SEC_TYPE_STACK;
  static const SectionType SEC_TYPE_PLTOFF = Section_SectionType_SEC_TYPE_PLTOFF;
  static const SectionType SEC_TYPE_HASH = Section_SectionType_SEC_TYPE_HASH;
  static const SectionType SEC_TYPE_LSDA = Section_SectionType_SEC_TYPE_LSDA;
  static const SectionType SEC_TYPE_UNWIND = Section_SectionType_SEC_TYPE_UNWIND;
  static const SectionType SEC_TYPE_UNWINDINFO = Section_SectionType_SEC_TYPE_UNWINDINFO;
  static const SectionType SEC_TYPE_REGSYM = Section_SectionType_SEC_TYPE_REGSYM;
  static const SectionType SEC_TYPE_DYNSYM = Section_SectionType_SEC_TYPE_DYNSYM;
  static const SectionType SEC_TYPE_DEBUG = Section_SectionType_SEC_TYPE_DEBUG;
  static const SectionType SEC_TYPE_BSS = Section_SectionType_SEC_TYPE_BSS;
  static const SectionType SEC_TYPE_SYMSTR = Section_SectionType_SEC_TYPE_SYMSTR;
  static const SectionType SEC_TYPE_DYNSTR = Section_SectionType_SEC_TYPE_DYNSTR;
  static const SectionType SEC_TYPE_SECSTR = Section_SectionType_SEC_TYPE_SECSTR;
  static const SectionType SEC_TYPE_COMMENT = Section_SectionType_SEC_TYPE_COMMENT;
  static const SectionType SEC_TYPE_LOOS = Section_SectionType_SEC_TYPE_LOOS;
  static const SectionType SEC_TYPE_USER = Section_SectionType_SEC_TYPE_USER;
  static const SectionType SEC_TYPE_UNKNOWN = Section_SectionType_SEC_TYPE_UNKNOWN;
  static inline bool SectionType_IsValid(int value) {
    return Section_SectionType_IsValid(value);
  }
  static const SectionType SectionType_MIN =
    Section_SectionType_SectionType_MIN;
  static const SectionType SectionType_MAX =
    Section_SectionType_SectionType_MAX;
  static const int SectionType_ARRAYSIZE =
    Section_SectionType_SectionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SectionType_descriptor() {
    return Section_SectionType_descriptor();
  }
  static inline const ::std::string& SectionType_Name(SectionType value) {
    return Section_SectionType_Name(value);
  }
  static inline bool SectionType_Parse(const ::std::string& name,
      SectionType* value) {
    return Section_SectionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required uint64 address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required .ztrace.Section.SectionType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::ztrace::Section_SectionType type() const;
  inline void set_type(::ztrace::Section_SectionType value);
  
  // required bool mapped = 5;
  inline bool has_mapped() const;
  inline void clear_mapped();
  static const int kMappedFieldNumber = 5;
  inline bool mapped() const;
  inline void set_mapped(bool value);
  
  // required bool is_readable = 6;
  inline bool has_is_readable() const;
  inline void clear_is_readable();
  static const int kIsReadableFieldNumber = 6;
  inline bool is_readable() const;
  inline void set_is_readable(bool value);
  
  // required bool is_writeable = 7;
  inline bool has_is_writeable() const;
  inline void clear_is_writeable();
  static const int kIsWriteableFieldNumber = 7;
  inline bool is_writeable() const;
  inline void set_is_writeable(bool value);
  
  // required bool is_executable = 8;
  inline bool has_is_executable() const;
  inline void clear_is_executable();
  static const int kIsExecutableFieldNumber = 8;
  inline bool is_executable() const;
  inline void set_is_executable(bool value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Section)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mapped();
  inline void clear_has_mapped();
  inline void set_has_is_readable();
  inline void clear_has_is_readable();
  inline void set_has_is_writeable();
  inline void clear_has_is_writeable();
  inline void set_has_is_executable();
  inline void clear_has_is_executable();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint64 address_;
  ::google::protobuf::uint64 size_;
  int type_;
  bool mapped_;
  bool is_readable_;
  bool is_writeable_;
  bool is_executable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Section* default_instance_;
};
// -------------------------------------------------------------------

class ModuleLoad : public ::google::protobuf::Message {
 public:
  ModuleLoad();
  virtual ~ModuleLoad();
  
  ModuleLoad(const ModuleLoad& from);
  
  inline ModuleLoad& operator=(const ModuleLoad& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleLoad& default_instance();
  
  void Swap(ModuleLoad* other);
  
  // implements Message ----------------------------------------------
  
  ModuleLoad* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleLoad& from);
  void MergeFrom(const ModuleLoad& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ModuleLoad_ImageType ImageType;
  static const ImageType IMG_TYPE_INVALID = ModuleLoad_ImageType_IMG_TYPE_INVALID;
  static const ImageType IMG_TYPE_STATIC = ModuleLoad_ImageType_IMG_TYPE_STATIC;
  static const ImageType IMG_TYPE_SHARED = ModuleLoad_ImageType_IMG_TYPE_SHARED;
  static const ImageType IMG_TYPE_SHAREDLIB = ModuleLoad_ImageType_IMG_TYPE_SHAREDLIB;
  static const ImageType IMG_TYPE_RELOCATABLE = ModuleLoad_ImageType_IMG_TYPE_RELOCATABLE;
  static const ImageType IMG_TYPE_UNKNOWN = ModuleLoad_ImageType_IMG_TYPE_UNKNOWN;
  static inline bool ImageType_IsValid(int value) {
    return ModuleLoad_ImageType_IsValid(value);
  }
  static const ImageType ImageType_MIN =
    ModuleLoad_ImageType_ImageType_MIN;
  static const ImageType ImageType_MAX =
    ModuleLoad_ImageType_ImageType_MAX;
  static const int ImageType_ARRAYSIZE =
    ModuleLoad_ImageType_ImageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageType_descriptor() {
    return ModuleLoad_ImageType_descriptor();
  }
  static inline const ::std::string& ImageType_Name(ImageType value) {
    return ModuleLoad_ImageType_Name(value);
  }
  static inline bool ImageType_Parse(const ::std::string& name,
      ImageType* value) {
    return ModuleLoad_ImageType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required uint64 low_address = 3;
  inline bool has_low_address() const;
  inline void clear_low_address();
  static const int kLowAddressFieldNumber = 3;
  inline ::google::protobuf::uint64 low_address() const;
  inline void set_low_address(::google::protobuf::uint64 value);
  
  // required uint64 high_address = 4;
  inline bool has_high_address() const;
  inline void clear_high_address();
  static const int kHighAddressFieldNumber = 4;
  inline ::google::protobuf::uint64 high_address() const;
  inline void set_high_address(::google::protobuf::uint64 value);
  
  // required uint64 load_offset = 5;
  inline bool has_load_offset() const;
  inline void clear_load_offset();
  static const int kLoadOffsetFieldNumber = 5;
  inline ::google::protobuf::uint64 load_offset() const;
  inline void set_load_offset(::google::protobuf::uint64 value);
  
  // required .ztrace.ModuleLoad.ImageType image_type = 6;
  inline bool has_image_type() const;
  inline void clear_image_type();
  static const int kImageTypeFieldNumber = 6;
  inline ::ztrace::ModuleLoad_ImageType image_type() const;
  inline void set_image_type(::ztrace::ModuleLoad_ImageType value);
  
  // required bool is_main_executable = 7;
  inline bool has_is_main_executable() const;
  inline void clear_is_main_executable();
  static const int kIsMainExecutableFieldNumber = 7;
  inline bool is_main_executable() const;
  inline void set_is_main_executable(bool value);
  
  // required bool is_static_executable = 8;
  inline bool has_is_static_executable() const;
  inline void clear_is_static_executable();
  static const int kIsStaticExecutableFieldNumber = 8;
  inline bool is_static_executable() const;
  inline void set_is_static_executable(bool value);
  
  // repeated .ztrace.Section section = 9;
  inline int section_size() const;
  inline void clear_section();
  static const int kSectionFieldNumber = 9;
  inline const ::ztrace::Section& section(int index) const;
  inline ::ztrace::Section* mutable_section(int index);
  inline ::ztrace::Section* add_section();
  inline const ::google::protobuf::RepeatedPtrField< ::ztrace::Section >&
      section() const;
  inline ::google::protobuf::RepeatedPtrField< ::ztrace::Section >*
      mutable_section();
  
  // optional bytes contents = 10;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 10;
  inline const ::std::string& contents() const;
  inline void set_contents(const ::std::string& value);
  inline void set_contents(const char* value);
  inline void set_contents(const void* value, size_t size);
  inline ::std::string* mutable_contents();
  inline ::std::string* release_contents();
  
  // @@protoc_insertion_point(class_scope:ztrace.ModuleLoad)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_low_address();
  inline void clear_has_low_address();
  inline void set_has_high_address();
  inline void clear_has_high_address();
  inline void set_has_load_offset();
  inline void clear_has_load_offset();
  inline void set_has_image_type();
  inline void clear_has_image_type();
  inline void set_has_is_main_executable();
  inline void clear_has_is_main_executable();
  inline void set_has_is_static_executable();
  inline void clear_has_is_static_executable();
  inline void set_has_contents();
  inline void clear_has_contents();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint64 low_address_;
  ::google::protobuf::uint32 id_;
  int image_type_;
  ::google::protobuf::uint64 high_address_;
  ::google::protobuf::uint64 load_offset_;
  ::google::protobuf::RepeatedPtrField< ::ztrace::Section > section_;
  ::std::string* contents_;
  bool is_main_executable_;
  bool is_static_executable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static ModuleLoad* default_instance_;
};
// -------------------------------------------------------------------

class ModuleUnload : public ::google::protobuf::Message {
 public:
  ModuleUnload();
  virtual ~ModuleUnload();
  
  ModuleUnload(const ModuleUnload& from);
  
  inline ModuleUnload& operator=(const ModuleUnload& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleUnload& default_instance();
  
  void Swap(ModuleUnload* other);
  
  // implements Message ----------------------------------------------
  
  ModuleUnload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleUnload& from);
  void MergeFrom(const ModuleUnload& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.ModuleUnload)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static ModuleUnload* default_instance_;
};
// -------------------------------------------------------------------

class SymbolEntry : public ::google::protobuf::Message {
 public:
  SymbolEntry();
  virtual ~SymbolEntry();
  
  SymbolEntry(const SymbolEntry& from);
  
  inline SymbolEntry& operator=(const SymbolEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolEntry& default_instance();
  
  void Swap(SymbolEntry* other);
  
  // implements Message ----------------------------------------------
  
  SymbolEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolEntry& from);
  void MergeFrom(const SymbolEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string undecorated_name = 3;
  inline bool has_undecorated_name() const;
  inline void clear_undecorated_name();
  static const int kUndecoratedNameFieldNumber = 3;
  inline const ::std::string& undecorated_name() const;
  inline void set_undecorated_name(const ::std::string& value);
  inline void set_undecorated_name(const char* value);
  inline void set_undecorated_name(const char* value, size_t size);
  inline ::std::string* mutable_undecorated_name();
  inline ::std::string* release_undecorated_name();
  
  // required bool is_dynamic = 4;
  inline bool has_is_dynamic() const;
  inline void clear_is_dynamic();
  static const int kIsDynamicFieldNumber = 4;
  inline bool is_dynamic() const;
  inline void set_is_dynamic(bool value);
  
  // required bool is_ifunc = 5;
  inline bool has_is_ifunc() const;
  inline void clear_is_ifunc();
  static const int kIsIfuncFieldNumber = 5;
  inline bool is_ifunc() const;
  inline void set_is_ifunc(bool value);
  
  // @@protoc_insertion_point(class_scope:ztrace.SymbolEntry)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_undecorated_name();
  inline void clear_has_undecorated_name();
  inline void set_has_is_dynamic();
  inline void clear_has_is_dynamic();
  inline void set_has_is_ifunc();
  inline void clear_has_is_ifunc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 address_;
  ::std::string* name_;
  ::std::string* undecorated_name_;
  bool is_dynamic_;
  bool is_ifunc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static SymbolEntry* default_instance_;
};
// -------------------------------------------------------------------

class ModuleSymbols : public ::google::protobuf::Message {
 public:
  ModuleSymbols();
  virtual ~ModuleSymbols();
  
  ModuleSymbols(const ModuleSymbols& from);
  
  inline ModuleSymbols& operator=(const ModuleSymbols& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleSymbols& default_instance();
  
  void Swap(ModuleSymbols* other);
  
  // implements Message ----------------------------------------------
  
  ModuleSymbols* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleSymbols& from);
  void MergeFrom(const ModuleSymbols& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 module_id = 1;
  inline bool has_module_id() const;
  inline void clear_module_id();
  static const int kModuleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 module_id() const;
  inline void set_module_id(::google::protobuf::uint32 value);
  
  // required string module_name = 2;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 2;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // repeated .ztrace.SymbolEntry sym = 3;
  inline int sym_size() const;
  inline void clear_sym();
  static const int kSymFieldNumber = 3;
  inline const ::ztrace::SymbolEntry& sym(int index) const;
  inline ::ztrace::SymbolEntry* mutable_sym(int index);
  inline ::ztrace::SymbolEntry* add_sym();
  inline const ::google::protobuf::RepeatedPtrField< ::ztrace::SymbolEntry >&
      sym() const;
  inline ::google::protobuf::RepeatedPtrField< ::ztrace::SymbolEntry >*
      mutable_sym();
  
  // @@protoc_insertion_point(class_scope:ztrace.ModuleSymbols)
 private:
  inline void set_has_module_id();
  inline void clear_has_module_id();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* module_name_;
  ::google::protobuf::RepeatedPtrField< ::ztrace::SymbolEntry > sym_;
  ::google::protobuf::uint32 module_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static ModuleSymbols* default_instance_;
};
// -------------------------------------------------------------------

class Malloc : public ::google::protobuf::Message {
 public:
  Malloc();
  virtual ~Malloc();
  
  Malloc(const Malloc& from);
  
  inline Malloc& operator=(const Malloc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Malloc& default_instance();
  
  void Swap(Malloc* other);
  
  // implements Message ----------------------------------------------
  
  Malloc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Malloc& from);
  void MergeFrom(const Malloc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 n = 1;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 1;
  inline ::google::protobuf::uint64 n() const;
  inline void set_n(::google::protobuf::uint64 value);
  
  // required uint64 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::uint64 ret() const;
  inline void set_ret(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Malloc)
 private:
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_ret();
  inline void clear_has_ret();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 n_;
  ::google::protobuf::uint64 ret_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Malloc* default_instance_;
};
// -------------------------------------------------------------------

class Calloc : public ::google::protobuf::Message {
 public:
  Calloc();
  virtual ~Calloc();
  
  Calloc(const Calloc& from);
  
  inline Calloc& operator=(const Calloc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Calloc& default_instance();
  
  void Swap(Calloc* other);
  
  // implements Message ----------------------------------------------
  
  Calloc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Calloc& from);
  void MergeFrom(const Calloc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 n = 1;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 1;
  inline ::google::protobuf::uint64 n() const;
  inline void set_n(::google::protobuf::uint64 value);
  
  // required uint64 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::uint64 ret() const;
  inline void set_ret(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Calloc)
 private:
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_ret();
  inline void clear_has_ret();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 n_;
  ::google::protobuf::uint64 ret_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Calloc* default_instance_;
};
// -------------------------------------------------------------------

class Free : public ::google::protobuf::Message {
 public:
  Free();
  virtual ~Free();
  
  Free(const Free& from);
  
  inline Free& operator=(const Free& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Free& default_instance();
  
  void Swap(Free* other);
  
  // implements Message ----------------------------------------------
  
  Free* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Free& from);
  void MergeFrom(const Free& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline ::google::protobuf::uint64 p() const;
  inline void set_p(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Free)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 p_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Free* default_instance_;
};
// -------------------------------------------------------------------

class Realloc : public ::google::protobuf::Message {
 public:
  Realloc();
  virtual ~Realloc();
  
  Realloc(const Realloc& from);
  
  inline Realloc& operator=(const Realloc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Realloc& default_instance();
  
  void Swap(Realloc* other);
  
  // implements Message ----------------------------------------------
  
  Realloc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Realloc& from);
  void MergeFrom(const Realloc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline ::google::protobuf::uint64 p() const;
  inline void set_p(::google::protobuf::uint64 value);
  
  // required uint64 n = 2;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 2;
  inline ::google::protobuf::uint64 n() const;
  inline void set_n(::google::protobuf::uint64 value);
  
  // required uint64 ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline ::google::protobuf::uint64 ret() const;
  inline void set_ret(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Realloc)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_ret();
  inline void clear_has_ret();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 p_;
  ::google::protobuf::uint64 n_;
  ::google::protobuf::uint64 ret_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Realloc* default_instance_;
};
// -------------------------------------------------------------------

class HeapOperation : public ::google::protobuf::Message {
 public:
  HeapOperation();
  virtual ~HeapOperation();
  
  HeapOperation(const HeapOperation& from);
  
  inline HeapOperation& operator=(const HeapOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeapOperation& default_instance();
  
  void Swap(HeapOperation* other);
  
  // implements Message ----------------------------------------------
  
  HeapOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeapOperation& from);
  void MergeFrom(const HeapOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ztrace.Malloc malloc = 1;
  inline bool has_malloc() const;
  inline void clear_malloc();
  static const int kMallocFieldNumber = 1;
  inline const ::ztrace::Malloc& malloc() const;
  inline ::ztrace::Malloc* mutable_malloc();
  inline ::ztrace::Malloc* release_malloc();
  
  // optional .ztrace.Free free = 2;
  inline bool has_free() const;
  inline void clear_free();
  static const int kFreeFieldNumber = 2;
  inline const ::ztrace::Free& free() const;
  inline ::ztrace::Free* mutable_free();
  inline ::ztrace::Free* release_free();
  
  // optional .ztrace.Realloc realloc = 3;
  inline bool has_realloc() const;
  inline void clear_realloc();
  static const int kReallocFieldNumber = 3;
  inline const ::ztrace::Realloc& realloc() const;
  inline ::ztrace::Realloc* mutable_realloc();
  inline ::ztrace::Realloc* release_realloc();
  
  // @@protoc_insertion_point(class_scope:ztrace.HeapOperation)
 private:
  inline void set_has_malloc();
  inline void clear_has_malloc();
  inline void set_has_free();
  inline void clear_has_free();
  inline void set_has_realloc();
  inline void clear_has_realloc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ztrace::Malloc* malloc_;
  ::ztrace::Free* free_;
  ::ztrace::Realloc* realloc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static HeapOperation* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();
  
  Value(const Value& from);
  
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();
  
  void Swap(Value* other);
  
  // implements Message ----------------------------------------------
  
  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 v_uint64 = 1;
  inline bool has_v_uint64() const;
  inline void clear_v_uint64();
  static const int kVUint64FieldNumber = 1;
  inline ::google::protobuf::uint64 v_uint64() const;
  inline void set_v_uint64(::google::protobuf::uint64 value);
  
  // optional int64 v_int64 = 2;
  inline bool has_v_int64() const;
  inline void clear_v_int64();
  static const int kVInt64FieldNumber = 2;
  inline ::google::protobuf::int64 v_int64() const;
  inline void set_v_int64(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Value)
 private:
  inline void set_has_v_uint64();
  inline void clear_has_v_uint64();
  inline void set_has_v_int64();
  inline void clear_has_v_int64();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 v_uint64_;
  ::google::protobuf::int64 v_int64_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class FunctionArgument : public ::google::protobuf::Message {
 public:
  FunctionArgument();
  virtual ~FunctionArgument();
  
  FunctionArgument(const FunctionArgument& from);
  
  inline FunctionArgument& operator=(const FunctionArgument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionArgument& default_instance();
  
  void Swap(FunctionArgument* other);
  
  // implements Message ----------------------------------------------
  
  FunctionArgument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionArgument& from);
  void MergeFrom(const FunctionArgument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ztrace.Value value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::ztrace::Value& value() const;
  inline ::ztrace::Value* mutable_value();
  inline ::ztrace::Value* release_value();
  
  // @@protoc_insertion_point(class_scope:ztrace.FunctionArgument)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ztrace::Value* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static FunctionArgument* default_instance_;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::Message {
 public:
  FunctionCall();
  virtual ~FunctionCall();
  
  FunctionCall(const FunctionCall& from);
  
  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionCall& default_instance();
  
  void Swap(FunctionCall* other);
  
  // implements Message ----------------------------------------------
  
  FunctionCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required uint32 module_id = 2;
  inline bool has_module_id() const;
  inline void clear_module_id();
  static const int kModuleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 module_id() const;
  inline void set_module_id(::google::protobuf::uint32 value);
  
  // optional .ztrace.Value ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline const ::ztrace::Value& ret() const;
  inline ::ztrace::Value* mutable_ret();
  inline ::ztrace::Value* release_ret();
  
  // repeated .ztrace.Value arg = 4;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 4;
  inline const ::ztrace::Value& arg(int index) const;
  inline ::ztrace::Value* mutable_arg(int index);
  inline ::ztrace::Value* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::ztrace::Value >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::ztrace::Value >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:ztrace.FunctionCall)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_module_id();
  inline void clear_has_module_id();
  inline void set_has_ret();
  inline void clear_has_ret();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::ztrace::Value* ret_;
  ::google::protobuf::RepeatedPtrField< ::ztrace::Value > arg_;
  ::google::protobuf::uint32 module_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static FunctionCall* default_instance_;
};
// -------------------------------------------------------------------

class ThreadStart : public ::google::protobuf::Message {
 public:
  ThreadStart();
  virtual ~ThreadStart();
  
  ThreadStart(const ThreadStart& from);
  
  inline ThreadStart& operator=(const ThreadStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ThreadStart& default_instance();
  
  void Swap(ThreadStart* other);
  
  // implements Message ----------------------------------------------
  
  ThreadStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThreadStart& from);
  void MergeFrom(const ThreadStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.ThreadStart)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 flags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static ThreadStart* default_instance_;
};
// -------------------------------------------------------------------

class ThreadEnd : public ::google::protobuf::Message {
 public:
  ThreadEnd();
  virtual ~ThreadEnd();
  
  ThreadEnd(const ThreadEnd& from);
  
  inline ThreadEnd& operator=(const ThreadEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ThreadEnd& default_instance();
  
  void Swap(ThreadEnd* other);
  
  // implements Message ----------------------------------------------
  
  ThreadEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThreadEnd& from);
  void MergeFrom(const ThreadEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.ThreadEnd)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 flags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static ThreadEnd* default_instance_;
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message {
 public:
  Timestamp();
  virtual ~Timestamp();
  
  Timestamp(const Timestamp& from);
  
  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();
  
  void Swap(Timestamp* other);
  
  // implements Message ----------------------------------------------
  
  Timestamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 sec = 1;
  inline bool has_sec() const;
  inline void clear_sec();
  static const int kSecFieldNumber = 1;
  inline ::google::protobuf::uint32 sec() const;
  inline void set_sec(::google::protobuf::uint32 value);
  
  // required uint32 usec = 2;
  inline bool has_usec() const;
  inline void clear_usec();
  static const int kUsecFieldNumber = 2;
  inline ::google::protobuf::uint32 usec() const;
  inline void set_usec(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.Timestamp)
 private:
  inline void set_has_sec();
  inline void clear_has_sec();
  inline void set_has_usec();
  inline void clear_has_usec();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 sec_;
  ::google::protobuf::uint32 usec_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Timestamp* default_instance_;
};
// -------------------------------------------------------------------

class TraceStart : public ::google::protobuf::Message {
 public:
  TraceStart();
  virtual ~TraceStart();
  
  TraceStart(const TraceStart& from);
  
  inline TraceStart& operator=(const TraceStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceStart& default_instance();
  
  void Swap(TraceStart* other);
  
  // implements Message ----------------------------------------------
  
  TraceStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TraceStart& from);
  void MergeFrom(const TraceStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ztrace.Timestamp timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::ztrace::Timestamp& timestamp() const;
  inline ::ztrace::Timestamp* mutable_timestamp();
  inline ::ztrace::Timestamp* release_timestamp();
  
  // required .ztrace.Arch arch = 2;
  inline bool has_arch() const;
  inline void clear_arch();
  static const int kArchFieldNumber = 2;
  inline ztrace::Arch arch() const;
  inline void set_arch(ztrace::Arch value);
  
  // optional string software = 3;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 3;
  inline const ::std::string& software() const;
  inline void set_software(const ::std::string& value);
  inline void set_software(const char* value);
  inline void set_software(const char* value, size_t size);
  inline ::std::string* mutable_software();
  inline ::std::string* release_software();
  
  // optional string target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  
  // optional string cmdline = 5;
  inline bool has_cmdline() const;
  inline void clear_cmdline();
  static const int kCmdlineFieldNumber = 5;
  inline const ::std::string& cmdline() const;
  inline void set_cmdline(const ::std::string& value);
  inline void set_cmdline(const char* value);
  inline void set_cmdline(const char* value, size_t size);
  inline ::std::string* mutable_cmdline();
  inline ::std::string* release_cmdline();
  
  // optional string os_uname = 6;
  inline bool has_os_uname() const;
  inline void clear_os_uname();
  static const int kOsUnameFieldNumber = 6;
  inline const ::std::string& os_uname() const;
  inline void set_os_uname(const ::std::string& value);
  inline void set_os_uname(const char* value);
  inline void set_os_uname(const char* value, size_t size);
  inline ::std::string* mutable_os_uname();
  inline ::std::string* release_os_uname();
  
  // @@protoc_insertion_point(class_scope:ztrace.TraceStart)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_arch();
  inline void clear_has_arch();
  inline void set_has_software();
  inline void clear_has_software();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_cmdline();
  inline void clear_has_cmdline();
  inline void set_has_os_uname();
  inline void clear_has_os_uname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ztrace::Timestamp* timestamp_;
  ::std::string* software_;
  ::std::string* target_;
  ::std::string* cmdline_;
  ::std::string* os_uname_;
  int arch_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static TraceStart* default_instance_;
};
// -------------------------------------------------------------------

class TraceEnd : public ::google::protobuf::Message {
 public:
  TraceEnd();
  virtual ~TraceEnd();
  
  TraceEnd(const TraceEnd& from);
  
  inline TraceEnd& operator=(const TraceEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceEnd& default_instance();
  
  void Swap(TraceEnd* other);
  
  // implements Message ----------------------------------------------
  
  TraceEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TraceEnd& from);
  void MergeFrom(const TraceEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ztrace.Timestamp timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::ztrace::Timestamp& timestamp() const;
  inline ::ztrace::Timestamp* mutable_timestamp();
  inline ::ztrace::Timestamp* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:ztrace.TraceEnd)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ztrace::Timestamp* timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static TraceEnd* default_instance_;
};
// -------------------------------------------------------------------

class MicroEventLogPtr : public ::google::protobuf::Message {
 public:
  MicroEventLogPtr();
  virtual ~MicroEventLogPtr();
  
  MicroEventLogPtr(const MicroEventLogPtr& from);
  
  inline MicroEventLogPtr& operator=(const MicroEventLogPtr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MicroEventLogPtr& default_instance();
  
  void Swap(MicroEventLogPtr* other);
  
  // implements Message ----------------------------------------------
  
  MicroEventLogPtr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MicroEventLogPtr& from);
  void MergeFrom(const MicroEventLogPtr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 tid = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);
  
  // required uint32 next_instruction = 2;
  inline bool has_next_instruction() const;
  inline void clear_next_instruction();
  static const int kNextInstructionFieldNumber = 2;
  inline ::google::protobuf::uint32 next_instruction() const;
  inline void set_next_instruction(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ztrace.MicroEventLogPtr)
 private:
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_next_instruction();
  inline void clear_has_next_instruction();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 next_instruction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static MicroEventLogPtr* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);
  
  // required uint32 tid = 3;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 3;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);
  
  // repeated .ztrace.MicroEventLogPtr cross_ref = 100;
  inline int cross_ref_size() const;
  inline void clear_cross_ref();
  static const int kCrossRefFieldNumber = 100;
  inline const ::ztrace::MicroEventLogPtr& cross_ref(int index) const;
  inline ::ztrace::MicroEventLogPtr* mutable_cross_ref(int index);
  inline ::ztrace::MicroEventLogPtr* add_cross_ref();
  inline const ::google::protobuf::RepeatedPtrField< ::ztrace::MicroEventLogPtr >&
      cross_ref() const;
  inline ::google::protobuf::RepeatedPtrField< ::ztrace::MicroEventLogPtr >*
      mutable_cross_ref();
  
  // optional .ztrace.TraceStart trace_start = 10;
  inline bool has_trace_start() const;
  inline void clear_trace_start();
  static const int kTraceStartFieldNumber = 10;
  inline const ::ztrace::TraceStart& trace_start() const;
  inline ::ztrace::TraceStart* mutable_trace_start();
  inline ::ztrace::TraceStart* release_trace_start();
  
  // optional .ztrace.TraceEnd trace_end = 11;
  inline bool has_trace_end() const;
  inline void clear_trace_end();
  static const int kTraceEndFieldNumber = 11;
  inline const ::ztrace::TraceEnd& trace_end() const;
  inline ::ztrace::TraceEnd* mutable_trace_end();
  inline ::ztrace::TraceEnd* release_trace_end();
  
  // optional .ztrace.ThreadStart thread_start = 20;
  inline bool has_thread_start() const;
  inline void clear_thread_start();
  static const int kThreadStartFieldNumber = 20;
  inline const ::ztrace::ThreadStart& thread_start() const;
  inline ::ztrace::ThreadStart* mutable_thread_start();
  inline ::ztrace::ThreadStart* release_thread_start();
  
  // optional .ztrace.ThreadEnd thread_end = 21;
  inline bool has_thread_end() const;
  inline void clear_thread_end();
  static const int kThreadEndFieldNumber = 21;
  inline const ::ztrace::ThreadEnd& thread_end() const;
  inline ::ztrace::ThreadEnd* mutable_thread_end();
  inline ::ztrace::ThreadEnd* release_thread_end();
  
  // optional .ztrace.TraceDisassembly trace_disasm = 30;
  inline bool has_trace_disasm() const;
  inline void clear_trace_disasm();
  static const int kTraceDisasmFieldNumber = 30;
  inline const ::ztrace::TraceDisassembly& trace_disasm() const;
  inline ::ztrace::TraceDisassembly* mutable_trace_disasm();
  inline ::ztrace::TraceDisassembly* release_trace_disasm();
  
  // optional .ztrace.ModuleLoad mod_load = 40;
  inline bool has_mod_load() const;
  inline void clear_mod_load();
  static const int kModLoadFieldNumber = 40;
  inline const ::ztrace::ModuleLoad& mod_load() const;
  inline ::ztrace::ModuleLoad* mutable_mod_load();
  inline ::ztrace::ModuleLoad* release_mod_load();
  
  // optional .ztrace.ModuleUnload mod_unload = 41;
  inline bool has_mod_unload() const;
  inline void clear_mod_unload();
  static const int kModUnloadFieldNumber = 41;
  inline const ::ztrace::ModuleUnload& mod_unload() const;
  inline ::ztrace::ModuleUnload* mutable_mod_unload();
  inline ::ztrace::ModuleUnload* release_mod_unload();
  
  // optional .ztrace.ModuleSymbols mod_symbols = 42;
  inline bool has_mod_symbols() const;
  inline void clear_mod_symbols();
  static const int kModSymbolsFieldNumber = 42;
  inline const ::ztrace::ModuleSymbols& mod_symbols() const;
  inline ::ztrace::ModuleSymbols* mutable_mod_symbols();
  inline ::ztrace::ModuleSymbols* release_mod_symbols();
  
  // optional .ztrace.MicroEventLog micro_event_log = 50;
  inline bool has_micro_event_log() const;
  inline void clear_micro_event_log();
  static const int kMicroEventLogFieldNumber = 50;
  inline const ::ztrace::MicroEventLog& micro_event_log() const;
  inline ::ztrace::MicroEventLog* mutable_micro_event_log();
  inline ::ztrace::MicroEventLog* release_micro_event_log();
  
  // optional .ztrace.Malloc malloc = 60;
  inline bool has_malloc() const;
  inline void clear_malloc();
  static const int kMallocFieldNumber = 60;
  inline const ::ztrace::Malloc& malloc() const;
  inline ::ztrace::Malloc* mutable_malloc();
  inline ::ztrace::Malloc* release_malloc();
  
  // optional .ztrace.Realloc realloc = 61;
  inline bool has_realloc() const;
  inline void clear_realloc();
  static const int kReallocFieldNumber = 61;
  inline const ::ztrace::Realloc& realloc() const;
  inline ::ztrace::Realloc* mutable_realloc();
  inline ::ztrace::Realloc* release_realloc();
  
  // optional .ztrace.Free free = 62;
  inline bool has_free() const;
  inline void clear_free();
  static const int kFreeFieldNumber = 62;
  inline const ::ztrace::Free& free() const;
  inline ::ztrace::Free* mutable_free();
  inline ::ztrace::Free* release_free();
  
  // optional .ztrace.Calloc calloc = 63;
  inline bool has_calloc() const;
  inline void clear_calloc();
  static const int kCallocFieldNumber = 63;
  inline const ::ztrace::Calloc& calloc() const;
  inline ::ztrace::Calloc* mutable_calloc();
  inline ::ztrace::Calloc* release_calloc();
  
  // @@protoc_insertion_point(class_scope:ztrace.Event)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_trace_start();
  inline void clear_has_trace_start();
  inline void set_has_trace_end();
  inline void clear_has_trace_end();
  inline void set_has_thread_start();
  inline void clear_has_thread_start();
  inline void set_has_thread_end();
  inline void clear_has_thread_end();
  inline void set_has_trace_disasm();
  inline void clear_has_trace_disasm();
  inline void set_has_mod_load();
  inline void clear_has_mod_load();
  inline void set_has_mod_unload();
  inline void clear_has_mod_unload();
  inline void set_has_mod_symbols();
  inline void clear_has_mod_symbols();
  inline void set_has_micro_event_log();
  inline void clear_has_micro_event_log();
  inline void set_has_malloc();
  inline void clear_has_malloc();
  inline void set_has_realloc();
  inline void clear_has_realloc();
  inline void set_has_free();
  inline void clear_has_free();
  inline void set_has_calloc();
  inline void clear_has_calloc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 pid_;
  ::google::protobuf::RepeatedPtrField< ::ztrace::MicroEventLogPtr > cross_ref_;
  ::ztrace::TraceStart* trace_start_;
  ::ztrace::TraceEnd* trace_end_;
  ::ztrace::ThreadStart* thread_start_;
  ::ztrace::ThreadEnd* thread_end_;
  ::ztrace::TraceDisassembly* trace_disasm_;
  ::ztrace::ModuleLoad* mod_load_;
  ::ztrace::ModuleUnload* mod_unload_;
  ::ztrace::ModuleSymbols* mod_symbols_;
  ::ztrace::MicroEventLog* micro_event_log_;
  ::ztrace::Malloc* malloc_;
  ::ztrace::Realloc* realloc_;
  ::ztrace::Free* free_;
  ::ztrace::Calloc* calloc_;
  ::google::protobuf::uint32 tid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZTrace_2eproto();
  friend void protobuf_AssignDesc_ZTrace_2eproto();
  friend void protobuf_ShutdownFile_ZTrace_2eproto();
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// ===================================================================


// ===================================================================

// MicroEventLog

// required uint64 start_instruction = 1;
inline bool MicroEventLog::has_start_instruction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MicroEventLog::set_has_start_instruction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MicroEventLog::clear_has_start_instruction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MicroEventLog::clear_start_instruction() {
  start_instruction_ = GOOGLE_ULONGLONG(0);
  clear_has_start_instruction();
}
inline ::google::protobuf::uint64 MicroEventLog::start_instruction() const {
  return start_instruction_;
}
inline void MicroEventLog::set_start_instruction(::google::protobuf::uint64 value) {
  set_has_start_instruction();
  start_instruction_ = value;
}

// required bytes data = 2;
inline bool MicroEventLog::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MicroEventLog::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MicroEventLog::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MicroEventLog::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MicroEventLog::data() const {
  return *data_;
}
inline void MicroEventLog::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MicroEventLog::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MicroEventLog::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MicroEventLog::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* MicroEventLog::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InsDisassembly

// required uint64 pc = 1;
inline bool InsDisassembly::has_pc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsDisassembly::set_has_pc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsDisassembly::clear_has_pc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsDisassembly::clear_pc() {
  pc_ = GOOGLE_ULONGLONG(0);
  clear_has_pc();
}
inline ::google::protobuf::uint64 InsDisassembly::pc() const {
  return pc_;
}
inline void InsDisassembly::set_pc(::google::protobuf::uint64 value) {
  set_has_pc();
  pc_ = value;
}

// required string text = 2;
inline bool InsDisassembly::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsDisassembly::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsDisassembly::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsDisassembly::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& InsDisassembly::text() const {
  return *text_;
}
inline void InsDisassembly::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void InsDisassembly::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void InsDisassembly::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsDisassembly::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* InsDisassembly::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes raw_bytes = 3;
inline bool InsDisassembly::has_raw_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsDisassembly::set_has_raw_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsDisassembly::clear_has_raw_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsDisassembly::clear_raw_bytes() {
  if (raw_bytes_ != &::google::protobuf::internal::kEmptyString) {
    raw_bytes_->clear();
  }
  clear_has_raw_bytes();
}
inline const ::std::string& InsDisassembly::raw_bytes() const {
  return *raw_bytes_;
}
inline void InsDisassembly::set_raw_bytes(const ::std::string& value) {
  set_has_raw_bytes();
  if (raw_bytes_ == &::google::protobuf::internal::kEmptyString) {
    raw_bytes_ = new ::std::string;
  }
  raw_bytes_->assign(value);
}
inline void InsDisassembly::set_raw_bytes(const char* value) {
  set_has_raw_bytes();
  if (raw_bytes_ == &::google::protobuf::internal::kEmptyString) {
    raw_bytes_ = new ::std::string;
  }
  raw_bytes_->assign(value);
}
inline void InsDisassembly::set_raw_bytes(const void* value, size_t size) {
  set_has_raw_bytes();
  if (raw_bytes_ == &::google::protobuf::internal::kEmptyString) {
    raw_bytes_ = new ::std::string;
  }
  raw_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsDisassembly::mutable_raw_bytes() {
  set_has_raw_bytes();
  if (raw_bytes_ == &::google::protobuf::internal::kEmptyString) {
    raw_bytes_ = new ::std::string;
  }
  return raw_bytes_;
}
inline ::std::string* InsDisassembly::release_raw_bytes() {
  clear_has_raw_bytes();
  if (raw_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raw_bytes_;
    raw_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BBLDisassembly

// repeated .ztrace.InsDisassembly ins_disasm = 1;
inline int BBLDisassembly::ins_disasm_size() const {
  return ins_disasm_.size();
}
inline void BBLDisassembly::clear_ins_disasm() {
  ins_disasm_.Clear();
}
inline const ::ztrace::InsDisassembly& BBLDisassembly::ins_disasm(int index) const {
  return ins_disasm_.Get(index);
}
inline ::ztrace::InsDisassembly* BBLDisassembly::mutable_ins_disasm(int index) {
  return ins_disasm_.Mutable(index);
}
inline ::ztrace::InsDisassembly* BBLDisassembly::add_ins_disasm() {
  return ins_disasm_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ztrace::InsDisassembly >&
BBLDisassembly::ins_disasm() const {
  return ins_disasm_;
}
inline ::google::protobuf::RepeatedPtrField< ::ztrace::InsDisassembly >*
BBLDisassembly::mutable_ins_disasm() {
  return &ins_disasm_;
}

// -------------------------------------------------------------------

// TraceDisassembly

// repeated .ztrace.BBLDisassembly bbl_disasm = 1;
inline int TraceDisassembly::bbl_disasm_size() const {
  return bbl_disasm_.size();
}
inline void TraceDisassembly::clear_bbl_disasm() {
  bbl_disasm_.Clear();
}
inline const ::ztrace::BBLDisassembly& TraceDisassembly::bbl_disasm(int index) const {
  return bbl_disasm_.Get(index);
}
inline ::ztrace::BBLDisassembly* TraceDisassembly::mutable_bbl_disasm(int index) {
  return bbl_disasm_.Mutable(index);
}
inline ::ztrace::BBLDisassembly* TraceDisassembly::add_bbl_disasm() {
  return bbl_disasm_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ztrace::BBLDisassembly >&
TraceDisassembly::bbl_disasm() const {
  return bbl_disasm_;
}
inline ::google::protobuf::RepeatedPtrField< ::ztrace::BBLDisassembly >*
TraceDisassembly::mutable_bbl_disasm() {
  return &bbl_disasm_;
}

// -------------------------------------------------------------------

// Section

// required string name = 1;
inline bool Section::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Section::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Section::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Section::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Section::name() const {
  return *name_;
}
inline void Section::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Section::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Section::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Section::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Section::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 address = 2;
inline bool Section::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Section::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Section::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Section::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 Section::address() const {
  return address_;
}
inline void Section::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required uint64 size = 3;
inline bool Section::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Section::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Section::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Section::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 Section::size() const {
  return size_;
}
inline void Section::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// required .ztrace.Section.SectionType type = 4;
inline bool Section::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Section::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Section::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Section::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ztrace::Section_SectionType Section::type() const {
  return static_cast< ::ztrace::Section_SectionType >(type_);
}
inline void Section::set_type(::ztrace::Section_SectionType value) {
  GOOGLE_DCHECK(::ztrace::Section_SectionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bool mapped = 5;
inline bool Section::has_mapped() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Section::set_has_mapped() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Section::clear_has_mapped() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Section::clear_mapped() {
  mapped_ = false;
  clear_has_mapped();
}
inline bool Section::mapped() const {
  return mapped_;
}
inline void Section::set_mapped(bool value) {
  set_has_mapped();
  mapped_ = value;
}

// required bool is_readable = 6;
inline bool Section::has_is_readable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Section::set_has_is_readable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Section::clear_has_is_readable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Section::clear_is_readable() {
  is_readable_ = false;
  clear_has_is_readable();
}
inline bool Section::is_readable() const {
  return is_readable_;
}
inline void Section::set_is_readable(bool value) {
  set_has_is_readable();
  is_readable_ = value;
}

// required bool is_writeable = 7;
inline bool Section::has_is_writeable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Section::set_has_is_writeable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Section::clear_has_is_writeable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Section::clear_is_writeable() {
  is_writeable_ = false;
  clear_has_is_writeable();
}
inline bool Section::is_writeable() const {
  return is_writeable_;
}
inline void Section::set_is_writeable(bool value) {
  set_has_is_writeable();
  is_writeable_ = value;
}

// required bool is_executable = 8;
inline bool Section::has_is_executable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Section::set_has_is_executable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Section::clear_has_is_executable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Section::clear_is_executable() {
  is_executable_ = false;
  clear_has_is_executable();
}
inline bool Section::is_executable() const {
  return is_executable_;
}
inline void Section::set_is_executable(bool value) {
  set_has_is_executable();
  is_executable_ = value;
}

// -------------------------------------------------------------------

// ModuleLoad

// required uint32 id = 1;
inline bool ModuleLoad::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleLoad::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleLoad::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleLoad::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ModuleLoad::id() const {
  return id_;
}
inline void ModuleLoad::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool ModuleLoad::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleLoad::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleLoad::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleLoad::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleLoad::name() const {
  return *name_;
}
inline void ModuleLoad::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleLoad::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleLoad::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleLoad::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleLoad::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 low_address = 3;
inline bool ModuleLoad::has_low_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModuleLoad::set_has_low_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModuleLoad::clear_has_low_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModuleLoad::clear_low_address() {
  low_address_ = GOOGLE_ULONGLONG(0);
  clear_has_low_address();
}
inline ::google::protobuf::uint64 ModuleLoad::low_address() const {
  return low_address_;
}
inline void ModuleLoad::set_low_address(::google::protobuf::uint64 value) {
  set_has_low_address();
  low_address_ = value;
}

// required uint64 high_address = 4;
inline bool ModuleLoad::has_high_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModuleLoad::set_has_high_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModuleLoad::clear_has_high_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModuleLoad::clear_high_address() {
  high_address_ = GOOGLE_ULONGLONG(0);
  clear_has_high_address();
}
inline ::google::protobuf::uint64 ModuleLoad::high_address() const {
  return high_address_;
}
inline void ModuleLoad::set_high_address(::google::protobuf::uint64 value) {
  set_has_high_address();
  high_address_ = value;
}

// required uint64 load_offset = 5;
inline bool ModuleLoad::has_load_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModuleLoad::set_has_load_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModuleLoad::clear_has_load_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModuleLoad::clear_load_offset() {
  load_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_load_offset();
}
inline ::google::protobuf::uint64 ModuleLoad::load_offset() const {
  return load_offset_;
}
inline void ModuleLoad::set_load_offset(::google::protobuf::uint64 value) {
  set_has_load_offset();
  load_offset_ = value;
}

// required .ztrace.ModuleLoad.ImageType image_type = 6;
inline bool ModuleLoad::has_image_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModuleLoad::set_has_image_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModuleLoad::clear_has_image_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModuleLoad::clear_image_type() {
  image_type_ = 0;
  clear_has_image_type();
}
inline ::ztrace::ModuleLoad_ImageType ModuleLoad::image_type() const {
  return static_cast< ::ztrace::ModuleLoad_ImageType >(image_type_);
}
inline void ModuleLoad::set_image_type(::ztrace::ModuleLoad_ImageType value) {
  GOOGLE_DCHECK(::ztrace::ModuleLoad_ImageType_IsValid(value));
  set_has_image_type();
  image_type_ = value;
}

// required bool is_main_executable = 7;
inline bool ModuleLoad::has_is_main_executable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModuleLoad::set_has_is_main_executable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModuleLoad::clear_has_is_main_executable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModuleLoad::clear_is_main_executable() {
  is_main_executable_ = false;
  clear_has_is_main_executable();
}
inline bool ModuleLoad::is_main_executable() const {
  return is_main_executable_;
}
inline void ModuleLoad::set_is_main_executable(bool value) {
  set_has_is_main_executable();
  is_main_executable_ = value;
}

// required bool is_static_executable = 8;
inline bool ModuleLoad::has_is_static_executable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModuleLoad::set_has_is_static_executable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModuleLoad::clear_has_is_static_executable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModuleLoad::clear_is_static_executable() {
  is_static_executable_ = false;
  clear_has_is_static_executable();
}
inline bool ModuleLoad::is_static_executable() const {
  return is_static_executable_;
}
inline void ModuleLoad::set_is_static_executable(bool value) {
  set_has_is_static_executable();
  is_static_executable_ = value;
}

// repeated .ztrace.Section section = 9;
inline int ModuleLoad::section_size() const {
  return section_.size();
}
inline void ModuleLoad::clear_section() {
  section_.Clear();
}
inline const ::ztrace::Section& ModuleLoad::section(int index) const {
  return section_.Get(index);
}
inline ::ztrace::Section* ModuleLoad::mutable_section(int index) {
  return section_.Mutable(index);
}
inline ::ztrace::Section* ModuleLoad::add_section() {
  return section_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ztrace::Section >&
ModuleLoad::section() const {
  return section_;
}
inline ::google::protobuf::RepeatedPtrField< ::ztrace::Section >*
ModuleLoad::mutable_section() {
  return &section_;
}

// optional bytes contents = 10;
inline bool ModuleLoad::has_contents() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ModuleLoad::set_has_contents() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ModuleLoad::clear_has_contents() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ModuleLoad::clear_contents() {
  if (contents_ != &::google::protobuf::internal::kEmptyString) {
    contents_->clear();
  }
  clear_has_contents();
}
inline const ::std::string& ModuleLoad::contents() const {
  return *contents_;
}
inline void ModuleLoad::set_contents(const ::std::string& value) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(value);
}
inline void ModuleLoad::set_contents(const char* value) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(value);
}
inline void ModuleLoad::set_contents(const void* value, size_t size) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleLoad::mutable_contents() {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  return contents_;
}
inline ::std::string* ModuleLoad::release_contents() {
  clear_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contents_;
    contents_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ModuleUnload

// required uint32 id = 1;
inline bool ModuleUnload::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleUnload::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleUnload::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleUnload::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ModuleUnload::id() const {
  return id_;
}
inline void ModuleUnload::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// SymbolEntry

// required uint64 address = 1;
inline bool SymbolEntry::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolEntry::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolEntry::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolEntry::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 SymbolEntry::address() const {
  return address_;
}
inline void SymbolEntry::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required string name = 2;
inline bool SymbolEntry::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolEntry::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolEntry::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SymbolEntry::name() const {
  return *name_;
}
inline void SymbolEntry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolEntry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolEntry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolEntry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SymbolEntry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string undecorated_name = 3;
inline bool SymbolEntry::has_undecorated_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolEntry::set_has_undecorated_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolEntry::clear_has_undecorated_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolEntry::clear_undecorated_name() {
  if (undecorated_name_ != &::google::protobuf::internal::kEmptyString) {
    undecorated_name_->clear();
  }
  clear_has_undecorated_name();
}
inline const ::std::string& SymbolEntry::undecorated_name() const {
  return *undecorated_name_;
}
inline void SymbolEntry::set_undecorated_name(const ::std::string& value) {
  set_has_undecorated_name();
  if (undecorated_name_ == &::google::protobuf::internal::kEmptyString) {
    undecorated_name_ = new ::std::string;
  }
  undecorated_name_->assign(value);
}
inline void SymbolEntry::set_undecorated_name(const char* value) {
  set_has_undecorated_name();
  if (undecorated_name_ == &::google::protobuf::internal::kEmptyString) {
    undecorated_name_ = new ::std::string;
  }
  undecorated_name_->assign(value);
}
inline void SymbolEntry::set_undecorated_name(const char* value, size_t size) {
  set_has_undecorated_name();
  if (undecorated_name_ == &::google::protobuf::internal::kEmptyString) {
    undecorated_name_ = new ::std::string;
  }
  undecorated_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolEntry::mutable_undecorated_name() {
  set_has_undecorated_name();
  if (undecorated_name_ == &::google::protobuf::internal::kEmptyString) {
    undecorated_name_ = new ::std::string;
  }
  return undecorated_name_;
}
inline ::std::string* SymbolEntry::release_undecorated_name() {
  clear_has_undecorated_name();
  if (undecorated_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = undecorated_name_;
    undecorated_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool is_dynamic = 4;
inline bool SymbolEntry::has_is_dynamic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolEntry::set_has_is_dynamic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolEntry::clear_has_is_dynamic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolEntry::clear_is_dynamic() {
  is_dynamic_ = false;
  clear_has_is_dynamic();
}
inline bool SymbolEntry::is_dynamic() const {
  return is_dynamic_;
}
inline void SymbolEntry::set_is_dynamic(bool value) {
  set_has_is_dynamic();
  is_dynamic_ = value;
}

// required bool is_ifunc = 5;
inline bool SymbolEntry::has_is_ifunc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolEntry::set_has_is_ifunc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolEntry::clear_has_is_ifunc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolEntry::clear_is_ifunc() {
  is_ifunc_ = false;
  clear_has_is_ifunc();
}
inline bool SymbolEntry::is_ifunc() const {
  return is_ifunc_;
}
inline void SymbolEntry::set_is_ifunc(bool value) {
  set_has_is_ifunc();
  is_ifunc_ = value;
}

// -------------------------------------------------------------------

// ModuleSymbols

// required uint32 module_id = 1;
inline bool ModuleSymbols::has_module_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleSymbols::set_has_module_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleSymbols::clear_has_module_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleSymbols::clear_module_id() {
  module_id_ = 0u;
  clear_has_module_id();
}
inline ::google::protobuf::uint32 ModuleSymbols::module_id() const {
  return module_id_;
}
inline void ModuleSymbols::set_module_id(::google::protobuf::uint32 value) {
  set_has_module_id();
  module_id_ = value;
}

// required string module_name = 2;
inline bool ModuleSymbols::has_module_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleSymbols::set_has_module_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleSymbols::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleSymbols::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& ModuleSymbols::module_name() const {
  return *module_name_;
}
inline void ModuleSymbols::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void ModuleSymbols::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void ModuleSymbols::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleSymbols::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* ModuleSymbols::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ztrace.SymbolEntry sym = 3;
inline int ModuleSymbols::sym_size() const {
  return sym_.size();
}
inline void ModuleSymbols::clear_sym() {
  sym_.Clear();
}
inline const ::ztrace::SymbolEntry& ModuleSymbols::sym(int index) const {
  return sym_.Get(index);
}
inline ::ztrace::SymbolEntry* ModuleSymbols::mutable_sym(int index) {
  return sym_.Mutable(index);
}
inline ::ztrace::SymbolEntry* ModuleSymbols::add_sym() {
  return sym_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ztrace::SymbolEntry >&
ModuleSymbols::sym() const {
  return sym_;
}
inline ::google::protobuf::RepeatedPtrField< ::ztrace::SymbolEntry >*
ModuleSymbols::mutable_sym() {
  return &sym_;
}

// -------------------------------------------------------------------

// Malloc

// required uint64 n = 1;
inline bool Malloc::has_n() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Malloc::set_has_n() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Malloc::clear_has_n() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Malloc::clear_n() {
  n_ = GOOGLE_ULONGLONG(0);
  clear_has_n();
}
inline ::google::protobuf::uint64 Malloc::n() const {
  return n_;
}
inline void Malloc::set_n(::google::protobuf::uint64 value) {
  set_has_n();
  n_ = value;
}

// required uint64 ret = 2;
inline bool Malloc::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Malloc::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Malloc::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Malloc::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 Malloc::ret() const {
  return ret_;
}
inline void Malloc::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// Calloc

// required uint64 n = 1;
inline bool Calloc::has_n() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Calloc::set_has_n() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Calloc::clear_has_n() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Calloc::clear_n() {
  n_ = GOOGLE_ULONGLONG(0);
  clear_has_n();
}
inline ::google::protobuf::uint64 Calloc::n() const {
  return n_;
}
inline void Calloc::set_n(::google::protobuf::uint64 value) {
  set_has_n();
  n_ = value;
}

// required uint64 ret = 2;
inline bool Calloc::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Calloc::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Calloc::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Calloc::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 Calloc::ret() const {
  return ret_;
}
inline void Calloc::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// Free

// required uint64 p = 1;
inline bool Free::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Free::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Free::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Free::clear_p() {
  p_ = GOOGLE_ULONGLONG(0);
  clear_has_p();
}
inline ::google::protobuf::uint64 Free::p() const {
  return p_;
}
inline void Free::set_p(::google::protobuf::uint64 value) {
  set_has_p();
  p_ = value;
}

// -------------------------------------------------------------------

// Realloc

// required uint64 p = 1;
inline bool Realloc::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Realloc::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Realloc::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Realloc::clear_p() {
  p_ = GOOGLE_ULONGLONG(0);
  clear_has_p();
}
inline ::google::protobuf::uint64 Realloc::p() const {
  return p_;
}
inline void Realloc::set_p(::google::protobuf::uint64 value) {
  set_has_p();
  p_ = value;
}

// required uint64 n = 2;
inline bool Realloc::has_n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Realloc::set_has_n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Realloc::clear_has_n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Realloc::clear_n() {
  n_ = GOOGLE_ULONGLONG(0);
  clear_has_n();
}
inline ::google::protobuf::uint64 Realloc::n() const {
  return n_;
}
inline void Realloc::set_n(::google::protobuf::uint64 value) {
  set_has_n();
  n_ = value;
}

// required uint64 ret = 3;
inline bool Realloc::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Realloc::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Realloc::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Realloc::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 Realloc::ret() const {
  return ret_;
}
inline void Realloc::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// HeapOperation

// optional .ztrace.Malloc malloc = 1;
inline bool HeapOperation::has_malloc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapOperation::set_has_malloc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapOperation::clear_has_malloc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapOperation::clear_malloc() {
  if (malloc_ != NULL) malloc_->::ztrace::Malloc::Clear();
  clear_has_malloc();
}
inline const ::ztrace::Malloc& HeapOperation::malloc() const {
  return malloc_ != NULL ? *malloc_ : *default_instance_->malloc_;
}
inline ::ztrace::Malloc* HeapOperation::mutable_malloc() {
  set_has_malloc();
  if (malloc_ == NULL) malloc_ = new ::ztrace::Malloc;
  return malloc_;
}
inline ::ztrace::Malloc* HeapOperation::release_malloc() {
  clear_has_malloc();
  ::ztrace::Malloc* temp = malloc_;
  malloc_ = NULL;
  return temp;
}

// optional .ztrace.Free free = 2;
inline bool HeapOperation::has_free() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeapOperation::set_has_free() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeapOperation::clear_has_free() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeapOperation::clear_free() {
  if (free_ != NULL) free_->::ztrace::Free::Clear();
  clear_has_free();
}
inline const ::ztrace::Free& HeapOperation::free() const {
  return free_ != NULL ? *free_ : *default_instance_->free_;
}
inline ::ztrace::Free* HeapOperation::mutable_free() {
  set_has_free();
  if (free_ == NULL) free_ = new ::ztrace::Free;
  return free_;
}
inline ::ztrace::Free* HeapOperation::release_free() {
  clear_has_free();
  ::ztrace::Free* temp = free_;
  free_ = NULL;
  return temp;
}

// optional .ztrace.Realloc realloc = 3;
inline bool HeapOperation::has_realloc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeapOperation::set_has_realloc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeapOperation::clear_has_realloc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeapOperation::clear_realloc() {
  if (realloc_ != NULL) realloc_->::ztrace::Realloc::Clear();
  clear_has_realloc();
}
inline const ::ztrace::Realloc& HeapOperation::realloc() const {
  return realloc_ != NULL ? *realloc_ : *default_instance_->realloc_;
}
inline ::ztrace::Realloc* HeapOperation::mutable_realloc() {
  set_has_realloc();
  if (realloc_ == NULL) realloc_ = new ::ztrace::Realloc;
  return realloc_;
}
inline ::ztrace::Realloc* HeapOperation::release_realloc() {
  clear_has_realloc();
  ::ztrace::Realloc* temp = realloc_;
  realloc_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Value

// optional uint64 v_uint64 = 1;
inline bool Value::has_v_uint64() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_v_uint64() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_v_uint64() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_v_uint64() {
  v_uint64_ = GOOGLE_ULONGLONG(0);
  clear_has_v_uint64();
}
inline ::google::protobuf::uint64 Value::v_uint64() const {
  return v_uint64_;
}
inline void Value::set_v_uint64(::google::protobuf::uint64 value) {
  set_has_v_uint64();
  v_uint64_ = value;
}

// optional int64 v_int64 = 2;
inline bool Value::has_v_int64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_v_int64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_v_int64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_v_int64() {
  v_int64_ = GOOGLE_LONGLONG(0);
  clear_has_v_int64();
}
inline ::google::protobuf::int64 Value::v_int64() const {
  return v_int64_;
}
inline void Value::set_v_int64(::google::protobuf::int64 value) {
  set_has_v_int64();
  v_int64_ = value;
}

// -------------------------------------------------------------------

// FunctionArgument

// required .ztrace.Value value = 1;
inline bool FunctionArgument::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionArgument::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionArgument::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionArgument::clear_value() {
  if (value_ != NULL) value_->::ztrace::Value::Clear();
  clear_has_value();
}
inline const ::ztrace::Value& FunctionArgument::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::ztrace::Value* FunctionArgument::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::ztrace::Value;
  return value_;
}
inline ::ztrace::Value* FunctionArgument::release_value() {
  clear_has_value();
  ::ztrace::Value* temp = value_;
  value_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FunctionCall

// required string name = 1;
inline bool FunctionCall::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionCall::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionCall::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionCall::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FunctionCall::name() const {
  return *name_;
}
inline void FunctionCall::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionCall::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionCall::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionCall::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FunctionCall::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 module_id = 2;
inline bool FunctionCall::has_module_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionCall::set_has_module_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionCall::clear_has_module_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionCall::clear_module_id() {
  module_id_ = 0u;
  clear_has_module_id();
}
inline ::google::protobuf::uint32 FunctionCall::module_id() const {
  return module_id_;
}
inline void FunctionCall::set_module_id(::google::protobuf::uint32 value) {
  set_has_module_id();
  module_id_ = value;
}

// optional .ztrace.Value ret = 3;
inline bool FunctionCall::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionCall::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionCall::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionCall::clear_ret() {
  if (ret_ != NULL) ret_->::ztrace::Value::Clear();
  clear_has_ret();
}
inline const ::ztrace::Value& FunctionCall::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::ztrace::Value* FunctionCall::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::ztrace::Value;
  return ret_;
}
inline ::ztrace::Value* FunctionCall::release_ret() {
  clear_has_ret();
  ::ztrace::Value* temp = ret_;
  ret_ = NULL;
  return temp;
}

// repeated .ztrace.Value arg = 4;
inline int FunctionCall::arg_size() const {
  return arg_.size();
}
inline void FunctionCall::clear_arg() {
  arg_.Clear();
}
inline const ::ztrace::Value& FunctionCall::arg(int index) const {
  return arg_.Get(index);
}
inline ::ztrace::Value* FunctionCall::mutable_arg(int index) {
  return arg_.Mutable(index);
}
inline ::ztrace::Value* FunctionCall::add_arg() {
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ztrace::Value >&
FunctionCall::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::ztrace::Value >*
FunctionCall::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// ThreadStart

// required uint32 flags = 1;
inline bool ThreadStart::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreadStart::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreadStart::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreadStart::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 ThreadStart::flags() const {
  return flags_;
}
inline void ThreadStart::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// ThreadEnd

// required uint32 flags = 2;
inline bool ThreadEnd::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreadEnd::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreadEnd::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreadEnd::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 ThreadEnd::flags() const {
  return flags_;
}
inline void ThreadEnd::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// Timestamp

// required uint32 sec = 1;
inline bool Timestamp::has_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamp::set_has_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timestamp::clear_has_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timestamp::clear_sec() {
  sec_ = 0u;
  clear_has_sec();
}
inline ::google::protobuf::uint32 Timestamp::sec() const {
  return sec_;
}
inline void Timestamp::set_sec(::google::protobuf::uint32 value) {
  set_has_sec();
  sec_ = value;
}

// required uint32 usec = 2;
inline bool Timestamp::has_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timestamp::set_has_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timestamp::clear_has_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timestamp::clear_usec() {
  usec_ = 0u;
  clear_has_usec();
}
inline ::google::protobuf::uint32 Timestamp::usec() const {
  return usec_;
}
inline void Timestamp::set_usec(::google::protobuf::uint32 value) {
  set_has_usec();
  usec_ = value;
}

// -------------------------------------------------------------------

// TraceStart

// required .ztrace.Timestamp timestamp = 1;
inline bool TraceStart::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceStart::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceStart::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceStart::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::ztrace::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::ztrace::Timestamp& TraceStart::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::ztrace::Timestamp* TraceStart::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::ztrace::Timestamp;
  return timestamp_;
}
inline ::ztrace::Timestamp* TraceStart::release_timestamp() {
  clear_has_timestamp();
  ::ztrace::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}

// required .ztrace.Arch arch = 2;
inline bool TraceStart::has_arch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStart::set_has_arch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStart::clear_has_arch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStart::clear_arch() {
  arch_ = 1;
  clear_has_arch();
}
inline ztrace::Arch TraceStart::arch() const {
  return static_cast< ztrace::Arch >(arch_);
}
inline void TraceStart::set_arch(ztrace::Arch value) {
  GOOGLE_DCHECK(ztrace::Arch_IsValid(value));
  set_has_arch();
  arch_ = value;
}

// optional string software = 3;
inline bool TraceStart::has_software() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStart::set_has_software() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStart::clear_has_software() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStart::clear_software() {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    software_->clear();
  }
  clear_has_software();
}
inline const ::std::string& TraceStart::software() const {
  return *software_;
}
inline void TraceStart::set_software(const ::std::string& value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void TraceStart::set_software(const char* value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void TraceStart::set_software(const char* value, size_t size) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TraceStart::mutable_software() {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  return software_;
}
inline ::std::string* TraceStart::release_software() {
  clear_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_;
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string target = 4;
inline bool TraceStart::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStart::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStart::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStart::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& TraceStart::target() const {
  return *target_;
}
inline void TraceStart::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TraceStart::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TraceStart::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TraceStart::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* TraceStart::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cmdline = 5;
inline bool TraceStart::has_cmdline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStart::set_has_cmdline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStart::clear_has_cmdline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStart::clear_cmdline() {
  if (cmdline_ != &::google::protobuf::internal::kEmptyString) {
    cmdline_->clear();
  }
  clear_has_cmdline();
}
inline const ::std::string& TraceStart::cmdline() const {
  return *cmdline_;
}
inline void TraceStart::set_cmdline(const ::std::string& value) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(value);
}
inline void TraceStart::set_cmdline(const char* value) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(value);
}
inline void TraceStart::set_cmdline(const char* value, size_t size) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TraceStart::mutable_cmdline() {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  return cmdline_;
}
inline ::std::string* TraceStart::release_cmdline() {
  clear_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmdline_;
    cmdline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string os_uname = 6;
inline bool TraceStart::has_os_uname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStart::set_has_os_uname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStart::clear_has_os_uname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStart::clear_os_uname() {
  if (os_uname_ != &::google::protobuf::internal::kEmptyString) {
    os_uname_->clear();
  }
  clear_has_os_uname();
}
inline const ::std::string& TraceStart::os_uname() const {
  return *os_uname_;
}
inline void TraceStart::set_os_uname(const ::std::string& value) {
  set_has_os_uname();
  if (os_uname_ == &::google::protobuf::internal::kEmptyString) {
    os_uname_ = new ::std::string;
  }
  os_uname_->assign(value);
}
inline void TraceStart::set_os_uname(const char* value) {
  set_has_os_uname();
  if (os_uname_ == &::google::protobuf::internal::kEmptyString) {
    os_uname_ = new ::std::string;
  }
  os_uname_->assign(value);
}
inline void TraceStart::set_os_uname(const char* value, size_t size) {
  set_has_os_uname();
  if (os_uname_ == &::google::protobuf::internal::kEmptyString) {
    os_uname_ = new ::std::string;
  }
  os_uname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TraceStart::mutable_os_uname() {
  set_has_os_uname();
  if (os_uname_ == &::google::protobuf::internal::kEmptyString) {
    os_uname_ = new ::std::string;
  }
  return os_uname_;
}
inline ::std::string* TraceStart::release_os_uname() {
  clear_has_os_uname();
  if (os_uname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_uname_;
    os_uname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TraceEnd

// required .ztrace.Timestamp timestamp = 2;
inline bool TraceEnd::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceEnd::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceEnd::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceEnd::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::ztrace::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::ztrace::Timestamp& TraceEnd::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::ztrace::Timestamp* TraceEnd::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::ztrace::Timestamp;
  return timestamp_;
}
inline ::ztrace::Timestamp* TraceEnd::release_timestamp() {
  clear_has_timestamp();
  ::ztrace::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MicroEventLogPtr

// required uint32 tid = 1;
inline bool MicroEventLogPtr::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MicroEventLogPtr::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MicroEventLogPtr::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MicroEventLogPtr::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 MicroEventLogPtr::tid() const {
  return tid_;
}
inline void MicroEventLogPtr::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// required uint32 next_instruction = 2;
inline bool MicroEventLogPtr::has_next_instruction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MicroEventLogPtr::set_has_next_instruction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MicroEventLogPtr::clear_has_next_instruction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MicroEventLogPtr::clear_next_instruction() {
  next_instruction_ = 0u;
  clear_has_next_instruction();
}
inline ::google::protobuf::uint32 MicroEventLogPtr::next_instruction() const {
  return next_instruction_;
}
inline void MicroEventLogPtr::set_next_instruction(::google::protobuf::uint32 value) {
  set_has_next_instruction();
  next_instruction_ = value;
}

// -------------------------------------------------------------------

// Event

// required uint32 id = 1;
inline bool Event::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Event::id() const {
  return id_;
}
inline void Event::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 pid = 2;
inline bool Event::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 Event::pid() const {
  return pid_;
}
inline void Event::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
}

// required uint32 tid = 3;
inline bool Event::has_tid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_tid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_tid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 Event::tid() const {
  return tid_;
}
inline void Event::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// repeated .ztrace.MicroEventLogPtr cross_ref = 100;
inline int Event::cross_ref_size() const {
  return cross_ref_.size();
}
inline void Event::clear_cross_ref() {
  cross_ref_.Clear();
}
inline const ::ztrace::MicroEventLogPtr& Event::cross_ref(int index) const {
  return cross_ref_.Get(index);
}
inline ::ztrace::MicroEventLogPtr* Event::mutable_cross_ref(int index) {
  return cross_ref_.Mutable(index);
}
inline ::ztrace::MicroEventLogPtr* Event::add_cross_ref() {
  return cross_ref_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ztrace::MicroEventLogPtr >&
Event::cross_ref() const {
  return cross_ref_;
}
inline ::google::protobuf::RepeatedPtrField< ::ztrace::MicroEventLogPtr >*
Event::mutable_cross_ref() {
  return &cross_ref_;
}

// optional .ztrace.TraceStart trace_start = 10;
inline bool Event::has_trace_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_trace_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_trace_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_trace_start() {
  if (trace_start_ != NULL) trace_start_->::ztrace::TraceStart::Clear();
  clear_has_trace_start();
}
inline const ::ztrace::TraceStart& Event::trace_start() const {
  return trace_start_ != NULL ? *trace_start_ : *default_instance_->trace_start_;
}
inline ::ztrace::TraceStart* Event::mutable_trace_start() {
  set_has_trace_start();
  if (trace_start_ == NULL) trace_start_ = new ::ztrace::TraceStart;
  return trace_start_;
}
inline ::ztrace::TraceStart* Event::release_trace_start() {
  clear_has_trace_start();
  ::ztrace::TraceStart* temp = trace_start_;
  trace_start_ = NULL;
  return temp;
}

// optional .ztrace.TraceEnd trace_end = 11;
inline bool Event::has_trace_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_trace_end() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_trace_end() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_trace_end() {
  if (trace_end_ != NULL) trace_end_->::ztrace::TraceEnd::Clear();
  clear_has_trace_end();
}
inline const ::ztrace::TraceEnd& Event::trace_end() const {
  return trace_end_ != NULL ? *trace_end_ : *default_instance_->trace_end_;
}
inline ::ztrace::TraceEnd* Event::mutable_trace_end() {
  set_has_trace_end();
  if (trace_end_ == NULL) trace_end_ = new ::ztrace::TraceEnd;
  return trace_end_;
}
inline ::ztrace::TraceEnd* Event::release_trace_end() {
  clear_has_trace_end();
  ::ztrace::TraceEnd* temp = trace_end_;
  trace_end_ = NULL;
  return temp;
}

// optional .ztrace.ThreadStart thread_start = 20;
inline bool Event::has_thread_start() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_thread_start() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_thread_start() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_thread_start() {
  if (thread_start_ != NULL) thread_start_->::ztrace::ThreadStart::Clear();
  clear_has_thread_start();
}
inline const ::ztrace::ThreadStart& Event::thread_start() const {
  return thread_start_ != NULL ? *thread_start_ : *default_instance_->thread_start_;
}
inline ::ztrace::ThreadStart* Event::mutable_thread_start() {
  set_has_thread_start();
  if (thread_start_ == NULL) thread_start_ = new ::ztrace::ThreadStart;
  return thread_start_;
}
inline ::ztrace::ThreadStart* Event::release_thread_start() {
  clear_has_thread_start();
  ::ztrace::ThreadStart* temp = thread_start_;
  thread_start_ = NULL;
  return temp;
}

// optional .ztrace.ThreadEnd thread_end = 21;
inline bool Event::has_thread_end() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Event::set_has_thread_end() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Event::clear_has_thread_end() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Event::clear_thread_end() {
  if (thread_end_ != NULL) thread_end_->::ztrace::ThreadEnd::Clear();
  clear_has_thread_end();
}
inline const ::ztrace::ThreadEnd& Event::thread_end() const {
  return thread_end_ != NULL ? *thread_end_ : *default_instance_->thread_end_;
}
inline ::ztrace::ThreadEnd* Event::mutable_thread_end() {
  set_has_thread_end();
  if (thread_end_ == NULL) thread_end_ = new ::ztrace::ThreadEnd;
  return thread_end_;
}
inline ::ztrace::ThreadEnd* Event::release_thread_end() {
  clear_has_thread_end();
  ::ztrace::ThreadEnd* temp = thread_end_;
  thread_end_ = NULL;
  return temp;
}

// optional .ztrace.TraceDisassembly trace_disasm = 30;
inline bool Event::has_trace_disasm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_trace_disasm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_trace_disasm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_trace_disasm() {
  if (trace_disasm_ != NULL) trace_disasm_->::ztrace::TraceDisassembly::Clear();
  clear_has_trace_disasm();
}
inline const ::ztrace::TraceDisassembly& Event::trace_disasm() const {
  return trace_disasm_ != NULL ? *trace_disasm_ : *default_instance_->trace_disasm_;
}
inline ::ztrace::TraceDisassembly* Event::mutable_trace_disasm() {
  set_has_trace_disasm();
  if (trace_disasm_ == NULL) trace_disasm_ = new ::ztrace::TraceDisassembly;
  return trace_disasm_;
}
inline ::ztrace::TraceDisassembly* Event::release_trace_disasm() {
  clear_has_trace_disasm();
  ::ztrace::TraceDisassembly* temp = trace_disasm_;
  trace_disasm_ = NULL;
  return temp;
}

// optional .ztrace.ModuleLoad mod_load = 40;
inline bool Event::has_mod_load() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Event::set_has_mod_load() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Event::clear_has_mod_load() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Event::clear_mod_load() {
  if (mod_load_ != NULL) mod_load_->::ztrace::ModuleLoad::Clear();
  clear_has_mod_load();
}
inline const ::ztrace::ModuleLoad& Event::mod_load() const {
  return mod_load_ != NULL ? *mod_load_ : *default_instance_->mod_load_;
}
inline ::ztrace::ModuleLoad* Event::mutable_mod_load() {
  set_has_mod_load();
  if (mod_load_ == NULL) mod_load_ = new ::ztrace::ModuleLoad;
  return mod_load_;
}
inline ::ztrace::ModuleLoad* Event::release_mod_load() {
  clear_has_mod_load();
  ::ztrace::ModuleLoad* temp = mod_load_;
  mod_load_ = NULL;
  return temp;
}

// optional .ztrace.ModuleUnload mod_unload = 41;
inline bool Event::has_mod_unload() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Event::set_has_mod_unload() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Event::clear_has_mod_unload() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Event::clear_mod_unload() {
  if (mod_unload_ != NULL) mod_unload_->::ztrace::ModuleUnload::Clear();
  clear_has_mod_unload();
}
inline const ::ztrace::ModuleUnload& Event::mod_unload() const {
  return mod_unload_ != NULL ? *mod_unload_ : *default_instance_->mod_unload_;
}
inline ::ztrace::ModuleUnload* Event::mutable_mod_unload() {
  set_has_mod_unload();
  if (mod_unload_ == NULL) mod_unload_ = new ::ztrace::ModuleUnload;
  return mod_unload_;
}
inline ::ztrace::ModuleUnload* Event::release_mod_unload() {
  clear_has_mod_unload();
  ::ztrace::ModuleUnload* temp = mod_unload_;
  mod_unload_ = NULL;
  return temp;
}

// optional .ztrace.ModuleSymbols mod_symbols = 42;
inline bool Event::has_mod_symbols() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Event::set_has_mod_symbols() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Event::clear_has_mod_symbols() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Event::clear_mod_symbols() {
  if (mod_symbols_ != NULL) mod_symbols_->::ztrace::ModuleSymbols::Clear();
  clear_has_mod_symbols();
}
inline const ::ztrace::ModuleSymbols& Event::mod_symbols() const {
  return mod_symbols_ != NULL ? *mod_symbols_ : *default_instance_->mod_symbols_;
}
inline ::ztrace::ModuleSymbols* Event::mutable_mod_symbols() {
  set_has_mod_symbols();
  if (mod_symbols_ == NULL) mod_symbols_ = new ::ztrace::ModuleSymbols;
  return mod_symbols_;
}
inline ::ztrace::ModuleSymbols* Event::release_mod_symbols() {
  clear_has_mod_symbols();
  ::ztrace::ModuleSymbols* temp = mod_symbols_;
  mod_symbols_ = NULL;
  return temp;
}

// optional .ztrace.MicroEventLog micro_event_log = 50;
inline bool Event::has_micro_event_log() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Event::set_has_micro_event_log() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Event::clear_has_micro_event_log() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Event::clear_micro_event_log() {
  if (micro_event_log_ != NULL) micro_event_log_->::ztrace::MicroEventLog::Clear();
  clear_has_micro_event_log();
}
inline const ::ztrace::MicroEventLog& Event::micro_event_log() const {
  return micro_event_log_ != NULL ? *micro_event_log_ : *default_instance_->micro_event_log_;
}
inline ::ztrace::MicroEventLog* Event::mutable_micro_event_log() {
  set_has_micro_event_log();
  if (micro_event_log_ == NULL) micro_event_log_ = new ::ztrace::MicroEventLog;
  return micro_event_log_;
}
inline ::ztrace::MicroEventLog* Event::release_micro_event_log() {
  clear_has_micro_event_log();
  ::ztrace::MicroEventLog* temp = micro_event_log_;
  micro_event_log_ = NULL;
  return temp;
}

// optional .ztrace.Malloc malloc = 60;
inline bool Event::has_malloc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Event::set_has_malloc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Event::clear_has_malloc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Event::clear_malloc() {
  if (malloc_ != NULL) malloc_->::ztrace::Malloc::Clear();
  clear_has_malloc();
}
inline const ::ztrace::Malloc& Event::malloc() const {
  return malloc_ != NULL ? *malloc_ : *default_instance_->malloc_;
}
inline ::ztrace::Malloc* Event::mutable_malloc() {
  set_has_malloc();
  if (malloc_ == NULL) malloc_ = new ::ztrace::Malloc;
  return malloc_;
}
inline ::ztrace::Malloc* Event::release_malloc() {
  clear_has_malloc();
  ::ztrace::Malloc* temp = malloc_;
  malloc_ = NULL;
  return temp;
}

// optional .ztrace.Realloc realloc = 61;
inline bool Event::has_realloc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Event::set_has_realloc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Event::clear_has_realloc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Event::clear_realloc() {
  if (realloc_ != NULL) realloc_->::ztrace::Realloc::Clear();
  clear_has_realloc();
}
inline const ::ztrace::Realloc& Event::realloc() const {
  return realloc_ != NULL ? *realloc_ : *default_instance_->realloc_;
}
inline ::ztrace::Realloc* Event::mutable_realloc() {
  set_has_realloc();
  if (realloc_ == NULL) realloc_ = new ::ztrace::Realloc;
  return realloc_;
}
inline ::ztrace::Realloc* Event::release_realloc() {
  clear_has_realloc();
  ::ztrace::Realloc* temp = realloc_;
  realloc_ = NULL;
  return temp;
}

// optional .ztrace.Free free = 62;
inline bool Event::has_free() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Event::set_has_free() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Event::clear_has_free() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Event::clear_free() {
  if (free_ != NULL) free_->::ztrace::Free::Clear();
  clear_has_free();
}
inline const ::ztrace::Free& Event::free() const {
  return free_ != NULL ? *free_ : *default_instance_->free_;
}
inline ::ztrace::Free* Event::mutable_free() {
  set_has_free();
  if (free_ == NULL) free_ = new ::ztrace::Free;
  return free_;
}
inline ::ztrace::Free* Event::release_free() {
  clear_has_free();
  ::ztrace::Free* temp = free_;
  free_ = NULL;
  return temp;
}

// optional .ztrace.Calloc calloc = 63;
inline bool Event::has_calloc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Event::set_has_calloc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Event::clear_has_calloc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Event::clear_calloc() {
  if (calloc_ != NULL) calloc_->::ztrace::Calloc::Clear();
  clear_has_calloc();
}
inline const ::ztrace::Calloc& Event::calloc() const {
  return calloc_ != NULL ? *calloc_ : *default_instance_->calloc_;
}
inline ::ztrace::Calloc* Event::mutable_calloc() {
  set_has_calloc();
  if (calloc_ == NULL) calloc_ = new ::ztrace::Calloc;
  return calloc_;
}
inline ::ztrace::Calloc* Event::release_calloc() {
  clear_has_calloc();
  ::ztrace::Calloc* temp = calloc_;
  calloc_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ztrace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ztrace::Section_SectionType>() {
  return ::ztrace::Section_SectionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ztrace::ModuleLoad_ImageType>() {
  return ::ztrace::ModuleLoad_ImageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ztrace::Arch>() {
  return ztrace::Arch_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ZTrace_2eproto__INCLUDED
